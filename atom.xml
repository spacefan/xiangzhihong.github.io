<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向志洪</title>
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiangzhihong.com/"/>
  <updated>2017-07-10T01:35:08.000Z</updated>
  <id>http://www.xiangzhihong.com/</id>
  
  <author>
    <name>xiangzhihong</name>
    <email>1044817967@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack+react环境搭建</title>
    <link href="http://www.xiangzhihong.com/2017/06/03/webpack+react%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.xiangzhihong.com/2017/06/03/webpack+react环境搭建/</id>
    <published>2017-06-02T16:00:00.000Z</published>
    <updated>2017-07-10T01:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道前端的框架纷繁复杂，各有各的优点。而我们选择使用React作为开发框架的时候，往往会选择Webpack+Babel+React来开始我们的项目。之前也讲过其他的前端框架，如<a href="http://blog.csdn.net/xiangzhihong8/article/details/53993980" target="_blank" rel="external"> gulp+webpack</a>，准确的说这不是一个框架，只是项目组织的形式而已。</p>
<h1 id="Webpack-Babel-React环境搭建"><a href="#Webpack-Babel-React环境搭建" class="headerlink" title="Webpack+Babel+React环境搭建"></a>Webpack+Babel+React环境搭建</h1><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>关于Webpack的介绍这里不讲解，大家可以看之前的讲解<a href="http://blog.csdn.net/xiangzhihong8/article/details/53993980" target="_blank" rel="external">webpack介绍</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack -g</div></pre></td></tr></table></figure>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>创建一个名叫learn-webpack项目，并进去项目目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir learn-webpack </div><div class="line">cd learn-webpack</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170104224231893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>接下来我们来创建2个文件:app.js和index.html，我们在也没上输出一个”Hello World”，<br>app.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.querySelector(&apos;#app&apos;).innerHTML = &apos;Hello World!&apos;;</div></pre></td></tr></table></figure></p>
<p>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;Learn-webpack&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>然后在终端执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack ./app.js ./dist/bundle.js</div></pre></td></tr></table></figure>
<p>最后执行启动本地的http服务，我们这里用python：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m SimpleHTTPServer</div></pre></td></tr></table></figure>
<p>然后我们访问：<a href="http://localhost:8000就可以看到效果了。" target="_blank" rel="external">http://localhost:8000就可以看到效果了。</a></p>
<h2 id="webpack文件配置"><a href="#webpack文件配置" class="headerlink" title="webpack文件配置"></a>webpack文件配置</h2><p>实际上每个项目下都应该包含一个webpack.config.js，用来告诉Webpack需要做些什么，这个我们之前文章也说过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &quot;app.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname+&quot;/dist&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们在终端运行命令，看看是不是和之前输入 webpack ./app.js ./dist/bundle.js 的打包编译结果一样呢，答案是肯定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure>
<p>注：<br><strong>entry：指定打包的入口文件</strong></p>
<ul>
<li>单个文件打包为单个输出文件，直接写该文件的名字，例如：entry:”main.js”</li>
<li>多个文件打包为单个输出文件，将文件名放进一个数组，例如：entry:[‘main.js’,’xx.js’]</li>
<li>多个文件打包为多个输出文件，将文件名放入一个键字对，例如：entry: {a:’main.js’,b:’xx.js’}<br><strong>output：配置打包结果</strong><br>path为定义输出文件夹，filename为打包结果文件的名称，如果指定打包入口文件为上面的1、2种情况，filename里面直接跟你想输出的文件名。若为第3种情况filename里面需写成[name].文件名.js，filename里面的[name]为entry中的键。<h3 id="监听变化自动打包"><a href="#监听变化自动打包" class="headerlink" title="监听变化自动打包"></a>监听变化自动打包</h3>当我们在不停的对代码进行变动的时候，为了不修改一次然后又手动去进行打包一次，可以使用webpack的watch功能。这也算是webpack的一个黑科技，以前做后端的时候必须重新部署，这个是很蛋疼的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --watch 或者 webpack -w</div></pre></td></tr></table></figure>
<p>或者我们可以直接在配置代码里面把watch设置为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &quot;app.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname+&quot;/dist&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;,</div><div class="line">  watch: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h2><p>Babel 是一个 JavaScript 编译器。使用它可以将ES6的语法转换为ES5的语法，以便在现在有的环境执行之前的代码。<br>首先安装basel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack babel-loader babel-core babel-preset-es2015 --save-dev</div></pre></td></tr></table></figure>
<p>执行安装完成后需要将之前的webpack.config.js修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &quot;./app.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname+&quot;/dist&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;</div><div class="line">        test: /\.jsx?$/,</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        exclude: /node_modules/,</div><div class="line">        query: &#123;</div><div class="line">          presets: [&apos;es2015&apos;]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    extensions: [&apos;&apos;,&apos;.coffee&apos;,&apos;.js&apos;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在就能在文件里面以ES6的语法进行代码编写，如在app.js加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func = str =&gt; &#123;</div><div class="line">  console.log(str);</div><div class="line">&#125;;</div><div class="line">func(&apos;Hello Babel!&apos;);</div></pre></td></tr></table></figure>
<p>我们再次运行，如果看到输出，就说明配置成功了。这里有关Loader的知识和配置就不讲究了，大家可以网上补补。</p>
<h2 id="与React结合"><a href="#与React结合" class="headerlink" title="与React结合"></a>与React结合</h2><p>终端输入以下代码对react和react-dom进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react react-dom --save</div></pre></td></tr></table></figure>
<p>安装Babel针对React的预设插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-react --save-dev</div></pre></td></tr></table></figure>
<p>由于我们增加了react的预设插件，所以需要对webpack.config.js进行修改。将module -&gt; loaders下面的query修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">query: &#123;</div><div class="line">    presets: [&apos;es2015&apos;,&apos;react&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们创建一个hello.js.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import React from &quot;react&quot;;</div><div class="line"></div><div class="line">class Hello extends React.Component&#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">          Hello, World!</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Hello;</div></pre></td></tr></table></figure>
<p>在app.js做一下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import React from &quot;react&quot;;</div><div class="line">import ReactDOM from &quot;react-dom&quot;;</div><div class="line">import Hello from &quot;./hello&quot;;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Hello /&gt;,</div><div class="line">  document.querySelector(&apos;#app&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>哈哈哈，这里如果大家做过React Native的，这里是不是感觉很亲切，只不过React Native还是用的npm在做管理。我们同样启动服务在看看，如果看到Hello World!就说明环境配置成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们知道前端的框架纷繁复杂，各有各的优点。而我们选择使用React作为开发框架的时候，往往会选择Webpack+Babel+React来开始
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端开发" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="react" scheme="http://www.xiangzhihong.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序尝鲜一个月现状分析</title>
    <link href="http://www.xiangzhihong.com/2017/02/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%9D%E9%B2%9C%E4%B8%80%E4%B8%AA%E6%9C%88%E7%8E%B0%E7%8A%B6%E5%88%86%E6%9E%90/"/>
    <id>http://www.xiangzhihong.com/2017/02/10/微信小程序尝鲜一个月现状分析/</id>
    <published>2017-02-09T16:00:00.000Z</published>
    <updated>2017-07-09T12:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>曾记得在微信小程序还没有上线的时候，大家都是翘首以待，希望在张小龙，在企鹅的带领下，走出区别于原生开发的另一条移动开发的道路，我也是一直关注着，知道1月9号，微信小程序终于对外开放了，作为第一批内测开发者，我也是在第一时间启动了微信小程序的开发。<br>其开发也确实相对简单，不过体验上嘛，可能和原生有一些差距，体验上有点类似于企业的x5渲染的webview。不过因为其高度依赖于微信这个平台，也限制了其开放性，所以我当时在csdn的内部群预言：微信小程序不会完全取代原生app，甚至都不可能威胁到原生app。<br>那么现在一个多月过去了，现状如何呢？</p>
<h1 id="微信小程序现状"><a href="#微信小程序现状" class="headerlink" title="微信小程序现状"></a>微信小程序现状</h1><p>就在过年之前，其实好多之前的微信小程序都悄悄下线了，诸如最早入住微信的ota，在过完年不就都纷纷下线，各种股票交易类的小程序也在证监会的要求下纷纷暂停服务。究其原因，就是其转换率并不高。<br>你是否有这样的困扰：手机里装了几十个甚至上百个App，但平均每天都会用到的数量屈指可数，又或者地图、外卖等同类App不得不装好几个换着用，明知使用频率不高却耗电、占内存就是删不得？也因为有这样的用户痛点，当“微信之父”张小龙对外阐释小程序是一个不需要下载安装就可使用的用完即走应用后一直备受关注。<br>2017微信公开课PRO版上，张小龙也举了两个小程序的场景化例子，一个是在公交站，扫一下站牌的二维码就可以了解下一辆公交车的到站时间；一个是在汽车站，扫一下二维码就可以购买车票而不需要排长队。<br>这样的示例已经说明了微信团队对小程序的定位和理解，明显看出重心是要深入开拓线下的场景运营。现在不管是在地铁、公交站等线下场景，许多广告牌中都已加入了二维码等待被“扫一扫”。但张小龙认为，对企业来说，广告中嵌入二维码，被扫后应该能直接触达企业服务而不是消息订阅。<br>他强调，更多希望小程序的启动来自于扫二维码。并且，小程序坚持去中心化的思路，不会有类似应用商店的分类、排行和推荐等功能，也不能推送消息，不会有订阅关系和粉丝机制。<br>值得注意的是，尽管微信官方反复说明小程序并非应用商店的复刻版，但关于小程序可能冲击原有App体系及应用市场的观点依然存在。原因在于，相比苹果iOS系统下App Store的一统江湖，国内的安卓应用市场因某些原因百花齐放，多个第三方应用商店并存。与此同时，流量分散、用户需求和习惯的变化加上技术变迁，都使得应用市场本身面临转型。<br>就在笔者写这篇散文的时候，谷歌正式推出了“谷歌小程序（Android Instant Apps）”。<br>那么这里要八卦一些了，什么是谷歌小程序（Android Instant Apps）？</p>
<h1 id="谷歌小程序"><a href="#谷歌小程序" class="headerlink" title="谷歌小程序"></a>谷歌小程序</h1><p>大家知道，不管是谷歌小程序还是微信小程序，都是一种轻量级的方法，其目的是：运行Android应用而无需安装、从任意位置访问应用。<br>在去年5月的Google I/O大会上，谷歌用了大约10分钟时间为我们介绍了Android Instant Apps，可理解为安卓“即时应用”，也就是无需安装可直接使用的应用，显然这跟微信推出的小程序非常类似，昨天，谷歌正式上线了一小批应用来测试这项功能。<br>上线的几款支持应用包括了BuzzFeed、Wish、Periscope以及Viki，Android Instant Apps并不是简单的网页浏览形式，通过Android Instant Apps，你其实就是打开了这个App的“简洁版”，经过一些媒体的测试，Android Instant Apps的加载速度也要比同等状况下的网页形式要快。<br>谷歌小程序工作原理：将App模块化了之后，Google Play只会在你点击了链接之后下载所需的那部分功能，这样你就相当于在一个简洁的模式下使用该App。对于开发者来说，他们也不必为此专门再去开发一个独立的App，它使用的还是同样的Android API和同样的源代码，开发者们只需要在原有App的基础上进行一下升级，接入Android Instant Apps的功能就可以了，对于一些开发者们来说，这个过程可能都用不了一天。<br>从这方面来说，由于google的全球影响力，加之在系统级别的多年耕耘，优势相对于微信小程序那可不是一点点。</p>
<h1 id="微信小程序的几大痛点"><a href="#微信小程序的几大痛点" class="headerlink" title="微信小程序的几大痛点"></a>微信小程序的几大痛点</h1><p>随着第一轮玩家激情褪去后的纷纷退场，以及第二批第三批玩家的涌入，为什么小程序的存活时间并不长？这不得不说说微信小程序当前存在的几个问题：</p>
<h2 id="bug较多"><a href="#bug较多" class="headerlink" title="bug较多"></a>bug较多</h2><p>这是不得不说的话题，小程序为了实现在苹果发布十周年推出具有“颠覆”的小程序，其实是带了很多bug上线的，即使到现在，开发人员依然会遇到很多问题。<br>对于人力充足的大公司，有专门的人来参与到小程序的开发维护中;而对于小公司，他们没有足够的人力投入，他们可能一半时间来维护其他平台产品另一半时间来开发小程序，这个时候如果碰到几个小程序的bug，基本上是吃不消的。</p>
<h2 id="产品定位"><a href="#产品定位" class="headerlink" title="产品定位"></a>产品定位</h2><p>举一个简单的例子，比如以内容为主的app，我们常常会向用户推送一些消息来提高点击率，但是在小程序里，这条路是死的。对于“今日头条”推出小程序真心搞不太懂，如此高频使用的产品为什么要放到小程序上，先不说重大新闻你怎么推送，那么对于普通用户的爱好如何进行个性化推荐?大概也是跟风吧。</p>
<h2 id="安全风险"><a href="#安全风险" class="headerlink" title="安全风险"></a>安全风险</h2><p>1月13日，证监会担心金融类小程序涉及客户隐私和安全问题，要求金融类的小程序只能进行产品的展示，不能进行诸如申购、赎回、转换、定投、开户等功能。那这就很蛋疼了，你只能在小程序上看最新的股价、咨询，你要想交易那对不起，你可以另跳链接，我们知道微信不支持外链的，那好吧，我得回到APP上，进行交易。那么问题来了，我APP啥都有了，我还要小程序干嘛，所以，很多基金、证券类的小程序直接停止服务。</p>
<h2 id="开发市场"><a href="#开发市场" class="headerlink" title="开发市场"></a>开发市场</h2><p>在小程序开放之前，微信小程序的群满天飞，首先是ios、android的开发者加入到了小程序开发群中，然后是PM也加入了进来，再到后排搞PHP的也加入了进来。小程序开发成本并不高，把官方文档的代码复制过来基本就能用，所以大家都来一起搞。其结果是其转换率并不高，其市场定位只能成为Android，ios的补充和附属品。</p>
<h1 id="小程序未来怎么走"><a href="#小程序未来怎么走" class="headerlink" title="小程序未来怎么走"></a>小程序未来怎么走</h1><p>独立互联网评论人洪波此前接受《每日经济新闻》记者采访时也认为，小程序毕竟是一个新东西，开发者可能会按照手机应用的流程去做小程序，这可能也是早期避免不了的。但小程序并不是免安装的手机应用，它最适合的场景是有一个明显的触发契机，大家需要对小程序应该怎么做、通过哪些场景触发等有个重新而且深入的思考。<br>虽然在推出当天，各类微信小程序一窝蜂的上线，但从推出后1个月的情况看，或许作为一个新思路的产品，没持续引发疯狂跟风反是个好信号，毕竟不管是对用户还是开发者来说，复制一个App生态体系意义不大，而思路和标准的改变跟产品开发都不能一蹴而就。<br>的确，作为线上的用户来说，小程序的设计似乎是如此不便，但换个角度来看，小程序或许本来就不是为被用户找到而设计的，或者说，致力于“勾连线下”的小程序，本身存在的价值或许是在特定的场景下找到特定的用户。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;曾记得在微信小程序还没有上线的时候，大家都是翘首以待，希望在张小龙，在企鹅的带领下，走出区别于原生开发的另一条移动开发的道路，我也是一直关注
    
    </summary>
    
      <category term="小程序" scheme="http://www.xiangzhihong.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://www.xiangzhihong.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信" scheme="http://www.xiangzhihong.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES简介</title>
    <link href="http://www.xiangzhihong.com/2017/01/05/OpenGL%20ES%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xiangzhihong.com/2017/01/05/OpenGL ES简介/</id>
    <published>2017-01-04T16:00:00.000Z</published>
    <updated>2017-07-10T01:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在聊Android的View渲染流程中，通常会有一个比较核心的步骤：通过OpeGL ES接口调用GPU接口通知GPU绘制图形。其完整的流程：UI对象—-&gt;CPU处理为多维图形,纹理 —–通过OpeGL ES接口调用GPU—-&gt; GPU对图进行光栅化(Frame Rate ) —-&gt;硬件时钟(Refresh Rate)—-垂直同步—-&gt;投射到屏幕。</p>
<p><img src="http://img.blog.csdn.net/20170317165805869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>详解的绘制原理，后面会慢慢讲的。</p>
<h2 id="渲染的基础知识"><a href="#渲染的基础知识" class="headerlink" title="渲染的基础知识"></a>渲染的基础知识</h2><p>使用OpenGL ES，一般包括如下几个步骤：</p>
<p>　　（1）EGL初始化<br>　　（2）OpenGL ES初始化<br>　　（3）OpenGL ES设置选项&amp;绘制<br>　　（4）OpenGL ES资源释放（可选）<br>　　（5）EGL资源释放</p>
<p>Android提供的GLSurfaceView和Renderer自动完成了（1）（5）两个部分，这部分只需要开发者做一些简单配置即可。另外（4）这一步是可选的，因为随着EGL中上下文的销毁，openGL ES用到的资源也跟着释放了。因此只有（2）（3）是开发者必须做的。这大大简化了开发过程，但是灵活性也有所降低，利用这两个类是无法完成offscreen render的。要想完成offscreen render其实也很简单，相信大家也都猜到了，只要我们把（1）~（5）都自己完成就可以了。后续部分的代码大部分都是C/C++，少部分是Java。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>EGL的功能是将OpenGL ES API和设备当前的窗口系统粘合在一起，起到了沟通桥梁的作用。不同设备的窗口系统千变万化，但是OpenGL ES提供的API却是统一的，所以EGL需要协调当前设备的窗口系统和OpenGL ES。下面EGL初始化的代码我是用C++写的，然后通过jni调用。Android在Java层面上也提供了对应的Java接口函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">static EGLConfig eglConf;</div><div class="line">static EGLSurface eglSurface;</div><div class="line">static EGLContext eglCtx;</div><div class="line">static EGLDisplay eglDisp;</div><div class="line"></div><div class="line">JNIEXPORT void JNICALL Java_com_handspeaker_offscreentest_MyGles_init</div><div class="line">(JNIEnv*env,jobject obj)</div><div class="line">&#123;</div><div class="line">    // EGL config attributes</div><div class="line">    const EGLint confAttr[] =</div><div class="line">    &#123;</div><div class="line">            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,// very important!</div><div class="line">            EGL_SURFACE_TYPE,EGL_PBUFFER_BIT,//EGL_WINDOW_BIT EGL_PBUFFER_BIT we will create a pixelbuffer surface</div><div class="line">            EGL_RED_SIZE,   8,</div><div class="line">            EGL_GREEN_SIZE, 8,</div><div class="line">            EGL_BLUE_SIZE,  8,</div><div class="line">            EGL_ALPHA_SIZE, 8,// if you need the alpha channel</div><div class="line">            EGL_DEPTH_SIZE, 8,// if you need the depth buffer</div><div class="line">            EGL_STENCIL_SIZE,8,</div><div class="line">            EGL_NONE</div><div class="line">    &#125;;</div><div class="line">    // EGL context attributes</div><div class="line">    const EGLint ctxAttr[] = &#123;</div><div class="line">            EGL_CONTEXT_CLIENT_VERSION, 2,// very important!</div><div class="line">            EGL_NONE</div><div class="line">    &#125;;</div><div class="line">    // surface attributes</div><div class="line">    // the surface size is set to the input frame size</div><div class="line">    const EGLint surfaceAttr[] = &#123;</div><div class="line">             EGL_WIDTH,512,</div><div class="line">             EGL_HEIGHT,512,</div><div class="line">             EGL_NONE</div><div class="line">    &#125;;</div><div class="line">    EGLint eglMajVers, eglMinVers;</div><div class="line">    EGLint numConfigs;</div><div class="line"></div><div class="line">    eglDisp = eglGetDisplay(EGL_DEFAULT_DISPLAY);</div><div class="line">    if(eglDisp == EGL_NO_DISPLAY)</div><div class="line">    &#123;</div><div class="line">        //Unable to open connection to local windowing system</div><div class="line">        LOGI(&quot;Unable to open connection to local windowing system&quot;);</div><div class="line">    &#125;</div><div class="line">    if(!eglInitialize(eglDisp, &amp;eglMajVers, &amp;eglMinVers))</div><div class="line">    &#123;</div><div class="line">        // Unable to initialize EGL. Handle and recover</div><div class="line">        LOGI(&quot;Unable to initialize EGL&quot;);</div><div class="line">    &#125;</div><div class="line">    LOGI(&quot;EGL init with version %d.%d&quot;, eglMajVers, eglMinVers);</div><div class="line">    // choose the first config, i.e. best config</div><div class="line">    if(!eglChooseConfig(eglDisp, confAttr, &amp;eglConf, 1, &amp;numConfigs))</div><div class="line">    &#123;</div><div class="line">        LOGI(&quot;some config is wrong&quot;);</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        LOGI(&quot;all configs is OK&quot;);</div><div class="line">    &#125;</div><div class="line">    // create a pixelbuffer surface</div><div class="line">    eglSurface = eglCreatePbufferSurface(eglDisp, eglConf, surfaceAttr);</div><div class="line">    if(eglSurface == EGL_NO_SURFACE)</div><div class="line">    &#123;</div><div class="line">        switch(eglGetError())</div><div class="line">        &#123;</div><div class="line">        case EGL_BAD_ALLOC:</div><div class="line">        // Not enough resources available. Handle and recover</div><div class="line">            LOGI(&quot;Not enough resources available&quot;);</div><div class="line">            break;</div><div class="line">        case EGL_BAD_CONFIG:</div><div class="line">        // Verify that provided EGLConfig is valid</div><div class="line">            LOGI(&quot;provided EGLConfig is invalid&quot;);</div><div class="line">            break;</div><div class="line">        case EGL_BAD_PARAMETER:</div><div class="line">        // Verify that the EGL_WIDTH and EGL_HEIGHT are</div><div class="line">        // non-negative values</div><div class="line">            LOGI(&quot;provided EGL_WIDTH and EGL_HEIGHT is invalid&quot;);</div><div class="line">            break;</div><div class="line">        case EGL_BAD_MATCH:</div><div class="line">        // Check window and EGLConfig attributes to determine</div><div class="line">        // compatibility and pbuffer-texture parameters</div><div class="line">            LOGI(&quot;Check window and EGLConfig attributes&quot;);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    eglCtx = eglCreateContext(eglDisp, eglConf, EGL_NO_CONTEXT, ctxAttr);</div><div class="line">    if(eglCtx == EGL_NO_CONTEXT)</div><div class="line">    &#123;</div><div class="line">        EGLint error = eglGetError();</div><div class="line">        if(error == EGL_BAD_CONFIG)</div><div class="line">        &#123;</div><div class="line">            // Handle error and recover</div><div class="line">            LOGI(&quot;EGL_BAD_CONFIG&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(!eglMakeCurrent(eglDisp, eglSurface, eglSurface, eglCtx))</div><div class="line">    &#123;</div><div class="line">        LOGI(&quot;MakeCurrent failed&quot;);</div><div class="line">    &#125;</div><div class="line">    LOGI(&quot;initialize success!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码比较长，不过大部分都是检测当前函数调用是否出错的，核心的函数只有6个，只要它们的调用没有问题即可：</p>
<p>eglGetDisplay(EGL_DEFAULT_DISPLAY)</p>
<p>eglInitialize(eglDisp, &amp;eglMajVers, &amp;eglMinVers)</p>
<p>eglChooseConfig(eglDisp, confAttr, &amp;eglConf, 1, &amp;numConfigs)</p>
<p>eglCreatePbufferSurface(eglDisp, eglConf, surfaceAttr)</p>
<p>eglCreateContext(eglDisp, eglConf, EGL_NO_CONTEXT, ctxAttr)</p>
<p>eglMakeCurrent(eglDisp, eglSurface, eglSurface, eglCtx)</p>
<h3 id="OpenGL-ES初始化"><a href="#OpenGL-ES初始化" class="headerlink" title="OpenGL ES初始化"></a>OpenGL ES初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT void JNICALL Java_com_handspeaker_offscreentest_MyGles_draw</div><div class="line">(JNIEnv*env,jobject obj)</div><div class="line">&#123;</div><div class="line">    const char*vertex_shader=vertex_shader_fix;</div><div class="line">    const char*fragment_shader=fragment_shader_simple;</div><div class="line">    glPixelStorei(GL_UNPACK_ALIGNMENT,1);</div><div class="line">    glClearColor(0.0,0.0,0.0,0.0);</div><div class="line">    glEnable(GL_DEPTH_TEST);</div><div class="line">    glDepthFunc(GL_LESS);</div><div class="line">    glCullFace(GL_BACK);</div><div class="line">    glViewport(0,0,512,512);</div><div class="line">    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);</div><div class="line">    glShaderSource(vertexShader,1,&amp;vertex_shader,NULL);</div><div class="line">    glCompileShader(vertexShader);</div><div class="line">    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</div><div class="line">    glShaderSource(fragmentShader,1,&amp;fragment_shader,NULL);</div><div class="line">    glCompileShader(fragmentShader);</div><div class="line">    GLuint program = glCreateProgram();</div><div class="line">    glAttachShader(program, vertexShader);</div><div class="line">    glAttachShader(program, fragmentShader);</div><div class="line">    glLinkProgram(program);</div><div class="line">    glUseProgram(program);</div><div class="line">    GLuint aPositionLocation =glGetAttribLocation(program, &quot;a_Position&quot;);</div><div class="line">    glVertexAttribPointer(aPositionLocation,2,GL_FLOAT,GL_FALSE,0,tableVerticesWithTriangles);</div><div class="line">    glEnableVertexAttribArray(aPositionLocation);</div><div class="line">    //draw something</div><div class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div><div class="line">    glDrawArrays(GL_TRIANGLES,0,6);</div><div class="line">    eglSwapBuffers(eglDisp,eglSurface);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="EGL资源释放"><a href="#EGL资源释放" class="headerlink" title="EGL资源释放"></a>EGL资源释放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT void JNICALL Java_com_handspeaker_offscreentest_MyGles_release</div><div class="line">(JNIEnv*env,jobject obj)</div><div class="line">&#123;</div><div class="line">    eglMakeCurrent(eglDisp, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</div><div class="line">    eglDestroyContext(eglDisp, eglCtx);</div><div class="line">    eglDestroySurface(eglDisp, eglSurface);</div><div class="line">    eglTerminate(eglDisp);</div><div class="line"></div><div class="line">    eglDisp = EGL_NO_DISPLAY;</div><div class="line">    eglSurface = EGL_NO_SURFACE;</div><div class="line">    eglCtx = EGL_NO_CONTEXT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="OpenGL-ES在Android中的应用"><a href="#OpenGL-ES在Android中的应用" class="headerlink" title="OpenGL ES在Android中的应用"></a>OpenGL ES在Android中的应用</h2><p>为了让你的控件能够显示在界面上，你必须创建一个view作为容器。而要想创建View容器，最直接的方式莫过于从GLSurfaceView和GLSurfaceView.Renderer分别派生一个类，实际的绘图动作都是在GLSurfaceView.Renderer里面发生的。对于一个全屏或近全屏的graphicsview，它是最好的选择。如果只是在某个小部分显示OpenGLES图形则可以考虑TextureView。当然你也可以直接继承自OpenGLES view创建一个View，不过一般都不会这么做。</p>
<h3 id="OpenGL-ES-的Android实例"><a href="#OpenGL-ES-的Android实例" class="headerlink" title="OpenGL ES 的Android实例"></a>OpenGL ES 的Android实例</h3><h4 id="1，在Manifest中声明使用OpenGLES"><a href="#1，在Manifest中声明使用OpenGLES" class="headerlink" title="1，在Manifest中声明使用OpenGLES"></a>1，在Manifest中声明使用OpenGLES</h4><p>为了能使用OpenGLES 2.0 API，你必须在你的manifest中添加以下声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure>
<p>如果你的应用要使用纹理压缩功能，还必须声明设备需要支持什么样的压缩格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;supports-gl-texture android:name=&quot;GL_OES_compressed_ETC1_RGB8_texture&quot; /&gt;</div><div class="line">&lt;supports-gl-texture android:name=&quot;GL_OES_compressed_paletted_texture&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="2-创建一个Activity"><a href="#2-创建一个Activity" class="headerlink" title="2,创建一个Activity"></a>2,创建一个Activity</h4><p>这个Activity和普通的activity一样，不过其使用的布局layout需要使用GLSurfaceView包裹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;GLSurfaceView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">     ....</div><div class="line">&lt;/GLSurfaceView&gt;</div></pre></td></tr></table></figure>
<p>注:OpenGL ES 2.0需要Android2.2 (API Level 8) 及以上版本。</p>
<h4 id="3，构键GLSurfaceView对象"><a href="#3，构键GLSurfaceView对象" class="headerlink" title="3，构键GLSurfaceView对象"></a>3，构键GLSurfaceView对象</h4><p>GLSurfaceView中其实不需要做太多工作，实际的绘制任务都在GLSurfaceView.Renderer中了。这里我们可以直接使用GLSurfaceView。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyGLSurfaceView extends GLSurfaceView &#123;</div><div class="line"></div><div class="line">    public MyGLSurfaceView(Context context)&#123;</div><div class="line">        super(context);</div><div class="line">        //设置Renderer到GLSurfaceView</div><div class="line">        setRenderer(new MyRenderer());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用OpenGLES 2.0时，你必须在GLSurfaceView构造器中调用另外一个函数，它说明了你将要使用2.0版的API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setEGLContextClientVersion(2);</div></pre></td></tr></table></figure>
<p>另一个可以添加的你的GLSurfaceView实现的可选的操作是设置render模式为只在绘制数据发生改变时才绘制view。使用GLSurfaceView.RENDERMODE_WHEN_DIRTY：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);</div></pre></td></tr></table></figure>
<p>####4， 构建一个Renderer类<br>Renderer类主要负责GLSurfaceView的绘制工作，它主要有三个方法：</p>
<ul>
<li>onSurfaceCreated()- 仅调用一次，用于设置view的OpenGLES环境。</li>
<li>onDrawFrame()- 每次View被重绘时被调用。</li>
<li>onSurfaceChanged()- 如果view的几和形状发生变化了就调用，例如当竖屏变为横屏时。</li>
</ul>
<p>如我们要在GLSurfaceView上画了一个灰色的背景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MyGL20Renderer implements GLSurfaceView.Renderer &#123;</div><div class="line"></div><div class="line">    public void onSurfaceCreated(GL10 unused, EGLConfig config) &#123;</div><div class="line">        //设置背景的颜色</div><div class="line">        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onDrawFrame(GL10 unused) &#123;</div><div class="line">        // 重绘背景色</div><div class="line">        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onSurfaceChanged(GL10 unused, int width, int height) &#123;</div><div class="line">        GLES20.glViewport(0, 0, width, height);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="OpenGL-ES渲染原理"><a href="#OpenGL-ES渲染原理" class="headerlink" title="OpenGL ES渲染原理"></a>OpenGL ES渲染原理</h1><p>首先来看一个OpenGL ES2.0的渲染原理图。</p>
<p><img src="http://img.blog.csdn.net/20170317205203849?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="1-VBO-VAO"><a href="#1-VBO-VAO" class="headerlink" title="1 VBO/VAO"></a>1 VBO/VAO</h2><p>VBO/VAO是cpu提供给GPU的顶点信息，包括了顶点的位置、颜色、纹理坐标（用于纹理贴图）等顶点信息。<br>VBO，全名Vertex Buffer Object。它是GPU里面的一块缓冲区，当我们需要传递数据的时候，可以先向GPU申请一块内存，然后往里面填充数据。最后，再通过调用glVertexAttribPointer把数据传递给Vertex Shader。<br>VAO，全名为Vertex Array Object，它的作用主要是记录当前有哪些VBO，每个VBO里面绑定的是什么数据，还有每一个vertex attribute绑定的是哪一个VBO。</p>
<h2 id="2-VertexShader（顶点着色器）"><a href="#2-VertexShader（顶点着色器）" class="headerlink" title="2 VertexShader（顶点着色器）"></a>2 VertexShader（顶点着色器）</h2><p>顶点着色器的输入数据由下面组成：</p>
<ul>
<li>Attributes：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点位置、颜色等</li>
<li>Uniforms：顶点着色器使用的常量数据，不能被着色器修改，一般用于对同一组顶点组成的单个3D物体中所有顶点都相同的变量，如当前光源的位置。</li>
<li>Samplers：这个是可选的，一种特殊的uniforms，表示顶点着色器使用的纹理。</li>
<li>Shader program：顶点着色器的源码或可执行文件，描述了将对顶点执行的操作。</li>
</ul>
<p>顶点着色器的输出：</p>
<ul>
<li>varying：在图元光栅化阶段，这些varying值为每个生成的片元进行计算，并将结果作为片元着色器的输入数据。从分配给每个顶点的原始varying值来为每个片元生成一个varying值的机制叫做插值。</li>
<li>另外，还有gl_postion、gl_FrontFacing和gl_PointSize。</li>
</ul>
<p>顶点着色器可用于传统的基于顶点的操作，例如：基于矩阵变换位置，进行光照计算来生成每个顶点的颜色，生成或者变换纹理坐标。<br>另外因为顶点着色器是由应用程序指定的，所以你可以用来进行任意自定义的顶点变换。</p>
<h2 id="3-PrimitiveAssembly（图元装配）："><a href="#3-PrimitiveAssembly（图元装配）：" class="headerlink" title="3 PrimitiveAssembly（图元装配）："></a>3 PrimitiveAssembly（图元装配）：</h2><p>顶点着色器下一个阶段是图元装配，这个阶段，把顶点着色器输出的顶点组合成图元。图元（primitive）是一个能用opengl es绘图命令绘制的几何体，包括三角形、直线或者点精灵等几何对象，绘图命令指定了一组顶点属性，描述了图元的几何形状和图元类型。在图元装配阶段，这些着色器处理过的顶点被组装到一个个独立的几何图元中，例如三角形、线、点精灵。对于每个图元，必须确定它是否位于视椎体内(3维空间显示在屏幕上的可见区域)，如果图元部分在视椎体中，需要进行裁剪，如果图元全部在视椎体外，则直接丢弃图元。裁剪之后，顶点位置转换成了屏幕坐标。背面剔除操作也会执行，它根据图元是正面还是背面，如果是背面则丢弃该图元。经过裁剪和背面剔除操作后，就进入渲染流水线的下一个阶段：光栅化。</p>
<h2 id="4-rasterization（光栅化）"><a href="#4-rasterization（光栅化）" class="headerlink" title="4 rasterization（光栅化）"></a>4 rasterization（光栅化）</h2><p><img src="http://img.blog.csdn.net/20170317211006433?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>光栅化是将图元转化为一组二维片段的过程，然后，这些片段由片段着色器处理（片段着色器的输入）。这些二维片段代表着可在屏幕上绘制的像素。用于从分配给每个图元顶点的顶点着色器输出生成每个片段值的机制称作插值（Interpolation）。这句不是人话的话解释了一个问题，就是从cpu提供的分散的顶点信息是如何变成屏幕上密集的像素的，图元装配后顶点可以理解成变为图形，光栅化时可以根据图形的形状，插值出那个图形区域的像素（纹理坐标v_texCoord、颜色等信息）。注意，此时的像素并不是屏幕上的像素，是不带有颜色的。接下来的片段着色器完成上色的工作。总之，光栅化阶段把图元转换成片元集合，之后会提交给片元着色器处理，这些片元集合表示可以被绘制到屏幕的像素。</p>
<h2 id="5-FragmentShader（片段着色器）"><a href="#5-FragmentShader（片段着色器）" class="headerlink" title="5 FragmentShader（片段着色器）"></a>5 FragmentShader（片段着色器）</h2><p><img src="http://img.blog.csdn.net/20170317211119324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>片段着色器为片段（像素）上的操作实现了通用的可编程方法，光栅化输出的每个片段都执行一遍片段着色器，对光栅化阶段生成每个片段执行这个着色器，生成一个或多个（多重渲染）颜色值作为输出。<br>片元着色器对片元实现了一种通用的可编程方法，它对光栅化阶段产生的每个片元进行操作，需要的输入数据如下：</p>
<ul>
<li>Varying variables：顶点着色器输出的varying变量经过光栅化插值计算后产生的作用于每个片元的值。</li>
<li>Uniforms：片元着色器使用的常量数据</li>
<li>Samplers：一种特殊的uniforms，表示片元着色器使用的纹理。</li>
<li>Shader program：片元着色器的源码或可执行文件，描述了将对片元执行的操作。</li>
</ul>
<p>片元着色器也可以丢弃片元或者为片元生成一个颜色值，保存到内置变量gl_FragColor。光栅化阶段产生的颜色、深度、模板和屏幕坐标(Xw, Yw)成为流水线中pre-fragment阶段(FragmentShader之后)的输入。</p>
<p>##６Per-Fragment Operations(逐个片元操作阶段)</p>
<p><img src="http://img.blog.csdn.net/20170317211329575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>片元着色器之后就是逐个片元操作阶段，包括一系列的测试阶段。一个光栅化阶段产生的具有屏幕坐标(Xw, Yw)的片元，只能修改framebuffer(帧缓冲)中位置在(Xw, Yw)的像素。</p>
<p>上图显示了Opengl es 2.0逐片元操作过程：</p>
<ul>
<li>Pixel ownership test：像素所有权测试决定framebuffer中某一个(Xw,Yw)位置的像素是否属于当前Opengl ES的context，比如：如果一个Opengl  ES帧缓冲窗口被其他窗口遮住了，窗口系统将决定被遮住的像素不属于当前Opengl ES的context，因此也就不会被显示。</li>
<li>Scissor test：裁剪测试决定位置为(Xw, Yw)的片元是否位于裁剪矩形内，如果不在，则被丢弃。</li>
<li>Stencil and depth tests：模板和深度测试传入片元的模板和深度值，决定是否丢弃片元。</li>
<li>Blending：将新产生的片元颜色值和framebuffer中某个(Xw, Yw)位置存储的颜色值进行混合。</li>
<li>Dithering：抖动可以用来最大限度的减少使用有限精度存储颜色值到framebuffer的工件。</li>
<li>逐片元操作之后，片元要么被丢弃，要么一个片元的颜色，深度或者模板值被写入到framebuffer的(Xw,Yw)位置，不过是否真的会写入还得依赖于write masks启用与否。write masks能更好的控制颜色、深度和模板值写入到合适的缓冲区。例如：颜色缓冲区中的write mask可以被设置成没有红色值写入到颜色缓冲区。另外，Opengl ES 2.0提framebuffer中获取像素的接口，不过需要记住的是像素只能从颜色缓冲区读回，深度和模板值不能读回。</li>
</ul>
<p>参考：<br>OpenGL渲染流程 <a href="http://www.cnblogs.com/BigFeng/p/5068715.html" target="_blank" rel="external">http://www.cnblogs.com/BigFeng/p/5068715.html</a><br>OpenGL ES 2.0渲染管线 <a href="http://codingnow.cn/opengles/1504.html" target="_blank" rel="external">http://codingnow.cn/opengles/1504.html</a><br>OpenGL ES 2.0可编程管道 <a href="http://www.cnblogs.com/listenheart/p/3292672.html" target="_blank" rel="external">http://www.cnblogs.com/listenheart/p/3292672.html</a><br>OpenGL ES 2.0编程基础 <a href="http://blog.csdn.net/iispring/article/details/7649628" target="_blank" rel="external">http://blog.csdn.net/iispring/article/details/7649628</a><br>OpenGL-渲染管线的流程 <a href="http://www.cnblogs.com/zhanglitong/p/3238989.html" target="_blank" rel="external">http://www.cnblogs.com/zhanglitong/p/3238989.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在聊Android的View渲染流程中，通常会有一个比较核心的步骤：通过OpeGL ES接口调用GPU接口通知GPU绘制图形。其完整的流程：
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="OpenGL" scheme="http://www.xiangzhihong.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>React Native打包</title>
    <link href="http://www.xiangzhihong.com/2017/01/03/React%20Native%E6%89%93%E5%8C%85/"/>
    <id>http://www.xiangzhihong.com/2017/01/03/React Native打包/</id>
    <published>2017-01-02T16:00:00.000Z</published>
    <updated>2017-07-10T01:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面写了关于React的一系列入门章：<a href="http://lib.csdn.net/xiangzhihong8/5375/chart/React%20Native" target="_blank" rel="external">http://lib.csdn.net/xiangzhihong8/5375/chart/React%20Native</a><br><img src="http://img.blog.csdn.net/20170227142756287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>欢迎大家吐槽，今天要说的是在Android和iOS两个平台如何打包的问题。</p>
<h1 id="Android平台打包"><a href="#Android平台打包" class="headerlink" title="Android平台打包"></a>Android平台打包</h1><p>Android平台有两种发布方式：一种是借助于命令行操作，另外一种是借助于Android Studio进行发布。</p>
<h2 id="Android-Studio平台发布"><a href="#Android-Studio平台发布" class="headerlink" title="Android Studio平台发布"></a>Android Studio平台发布</h2><p>借助于Android Studio生成签名keystore，然后生成签名包，这和传统的Native开发一样。</p>
<p><img src="http://img.blog.csdn.net/20170227143230527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>此时，你会发现，你可以继续生成一个apk，并且可以安装，但是却无法运行，发生闪退。这是因为React-Native的android平台下默认没有生成资源文件也就是我们所有的js图片文件等等。</p>
<p>下面我们就来生成JS Bundle文件：</p>
<h3 id="1，创建一个assets文件"><a href="#1，创建一个assets文件" class="headerlink" title="1，创建一个assets文件"></a>1，创建一个assets文件</h3><p>创建一个assets文件在工程目录下，可以通过命令行操作，也可手动，具体的命名是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p Android/app/src/main/assets</div></pre></td></tr></table></figure>
<h3 id="2，生成Bundle文件"><a href="#2，生成Bundle文件" class="headerlink" title="2，生成Bundle文件"></a>2，生成Bundle文件</h3><p>生成Bundle文件的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170227144340622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>我们已经完全生成了bundle文件了，可以查看自己工程assets下的文件夹，如果生成，则再次签名运行就没有问题。</p>
<h2 id="命令行发布版本"><a href="#命令行发布版本" class="headerlink" title="命令行发布版本"></a>命令行发布版本</h2><h3 id="生成签名文件"><a href="#生成签名文件" class="headerlink" title="生成签名文件"></a>生成签名文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000</div></pre></td></tr></table></figure>
<h3 id="修改android-gradle-properties文件"><a href="#修改android-gradle-properties文件" class="headerlink" title="修改android/gradle.properties文件"></a>修改android/gradle.properties文件</h3><p>编辑gradle文件，如果没有就创建一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MYAPP_RELEASE_STORE_FILE=my-release-key.keystore</div><div class="line">MYAPP_RELEASE_KEY_ALIAS=my-key-alias</div><div class="line">MYAPP_RELEASE_STORE_PASSWORD=*****</div><div class="line">MYAPP_RELEASE_KEY_PASSWORD=*****</div></pre></td></tr></table></figure>
<h3 id="修改签名gradle配置文件"><a href="#修改签名gradle配置文件" class="headerlink" title="修改签名gradle配置文件"></a>修改签名gradle配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    defaultConfig &#123; ... &#125;</div><div class="line">    signingConfigs &#123;</div><div class="line">        release &#123;</div><div class="line">            storeFile file(MYAPP_RELEASE_STORE_FILE)</div><div class="line">            storePassword MYAPP_RELEASE_STORE_PASSWORD</div><div class="line">            keyAlias MYAPP_RELEASE_KEY_ALIAS</div><div class="line">            keyPassword MYAPP_RELEASE_KEY_PASSWORD</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            ...</div><div class="line">            signingConfig signingConfigs.release</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="生成签名APK包"><a href="#生成签名APK包" class="headerlink" title="生成签名APK包"></a>生成签名APK包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew assembleRelease</div></pre></td></tr></table></figure>
<p>完成之后便会在android/app/build/outputs/apk/app-release.apk生成可安装包。</p>
<h1 id="IOS平台打包"><a href="#IOS平台打包" class="headerlink" title="IOS平台打包"></a>IOS平台打包</h1><p>相对于Android平台来讲，IOS平台的发布操作相对简单，只需要简单配置即可。</p>
<p>选择Product ⇒ Archive。</p>
<p><img src="http://img.blog.csdn.net/20170227145214049?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>等待系统打包，打包出来的即使ipa文件</p>
<p><img src="http://img.blog.csdn.net/20170227145259024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>附：<a href="http://www.jianshu.com/p/32a99c273be1" target="_blank" rel="external">http://www.jianshu.com/p/32a99c273be1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面写了关于React的一系列入门章：&lt;a href=&quot;http://lib.csdn.net/xiangzhihong8/5375/chart/React%20Native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lib.csdn.n
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
      <category term="打包" scheme="http://www.xiangzhihong.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>gulp+webpack工具整合简介</title>
    <link href="http://www.xiangzhihong.com/2016/12/05/gulp+webpack%E5%B7%A5%E5%85%B7%E6%95%B4%E5%90%88%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xiangzhihong.com/2016/12/05/gulp+webpack工具整合简介/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-07-10T01:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h2><p>Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><img src="http://img.blog.csdn.net/20170103123129506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="webpack特点"><a href="#webpack特点" class="headerlink" title="webpack特点"></a>webpack特点</h3><ul>
<li><p>Webpack<br>有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p>
</li>
<li><p>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript<br>模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p>
</li>
<li><p>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS<br>文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。</p>
</li>
<li><p>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack<br>插件，来满足各式各样的需求。</p>
</li>
<li><p>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p>
</li>
</ul>
<h3 id="webpack配置及使用"><a href="#webpack配置及使用" class="headerlink" title="webpack配置及使用"></a>webpack配置及使用</h3><p>首先需要安装node环境和npm包管理工具，不知道的可以自行百度。基本环境好了后需要安装webpack插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack --save-dev</div></pre></td></tr></table></figure>
<p>接下来就是写一个demo验证了。创建一个静态页面 index.html 和一个 JS 入口文件 entry.js<br><!-- index.html --><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p> entry.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;It works.&apos;)</div></pre></td></tr></table></figure></p>
<p>编译 entry.js 并打包到 bundle.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack entry.js bundle.js</div></pre></td></tr></table></figure>
<p>然后在浏览器上就可以看到输出结果了“It works”。</p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先安装loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader</div></pre></td></tr></table></figure>
<p>然后我们写代码的时候通过require函数引入进来就可以了，具体使用请自行搜索。</p>
<h2 id="gulp-简介"><a href="#gulp-简介" class="headerlink" title="gulp 简介"></a>gulp 简介</h2><p>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。<br>gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。<br>gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。</p>
<h3 id="gulp安装使用"><a href="#gulp安装使用" class="headerlink" title="gulp安装使用"></a>gulp安装使用</h3><h4 id="1、安装nodejs"><a href="#1、安装nodejs" class="headerlink" title="1、安装nodejs"></a>1、安装nodejs</h4><p>1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs；<br>1.2、安装：打开<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs官网</a>，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。然后一路next。</p>
<h4 id="2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）"><a href="#2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）" class="headerlink" title="2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）"></a>2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）</h4><p>2.1、说明：什么是命令行？命令行在OSX是终端（Terminal），在windows是命令提示符（Command Prompt）；<br>2.2、注：之后操作都是在windows系统下；<br>2.3、简单介绍gulp在使用过程中常用命令，打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）：<br>node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。PS：未能出现版本号，请尝试注销电脑重试；<br>npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器，那它有什么用呢？稍后解释；<br>cd定位到目录，用法：cd + 路径 ；<br>dir列出文件列表；<br>cls清空命令提示符窗口内容。<br><img src="http://img.blog.csdn.net/20170103204436639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="3、npm介绍"><a href="#3、npm介绍" class="headerlink" title="3、npm介绍"></a>3、npm介绍</h4><p>在这里直接略过，<a href="http://blog.csdn.net/xiangzhihong8/article/details/53422926" target="_blank" rel="external">npm详解</a></p>
<h4 id="4、选装cnpm"><a href="#4、选装cnpm" class="headerlink" title="4、选装cnpm"></a>4、选装cnpm</h4><p>4.1、说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”；<br>4.2、官方网址：<a href="http://npm.taobao.org；" target="_blank" rel="external">http://npm.taobao.org；</a><br>4.3、安装：命令提示符执行npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org；" target="_blank" rel="external">https://registry.npm.taobao.org；</a>  注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；<br>注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。</p>
<h4 id="5、全局安装gulp"><a href="#5、全局安装gulp" class="headerlink" title="5、全局安装gulp"></a>5、全局安装gulp</h4><p>5.1、说明：全局安装gulp目的是为了通过她执行gulp任务；<br>5.2、安装：命令提示符执行cnpm install gulp -g；<br>5.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。</p>
<h4 id="6、新建package-json文件"><a href="#6、新建package-json文件" class="headerlink" title="6、新建package.json文件"></a>6、新建package.json文件</h4><p>这个也忽略，相当于maven组织项目的。</p>
<h4 id="7、本地安装gulp插件"><a href="#7、本地安装gulp插件" class="headerlink" title="7、本地安装gulp插件"></a>7、本地安装gulp插件</h4><p>7.1、安装：定位目录命令后提示符执行cnpm install –save-dev；<br>7.2、本示例以gulp-less为例（编译less文件），命令提示符执行cnpm install gulp-less –save-dev；<br><img src="http://img.blog.csdn.net/20170103205009580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>7.3、将会安装在node_modules的gulp-less目录下，该目录下有一个gulp-less的使用帮助文档README.md；<br>7.4、为了能正常使用，我们还得本地安装gulp：cnpm install gulp –save-dev；<br>PS：细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。</p>
<h4 id="8、新建gulpfile-js文件（重要）"><a href="#8、新建gulpfile-js文件（重要）" class="headerlink" title="8、新建gulpfile.js文件（重要）"></a>8、新建gulpfile.js文件（重要）</h4><p>8.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。<br>8.2、它大概是这样一个js文件（更多插件配置请<a href="http://www.ydcss.com/archives/tag/gulp" target="_blank" rel="external">查看这里</a>）<br>来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//导入工具包 require(&apos;node_modules里对应模块&apos;)</div><div class="line">var gulp = require(&apos;gulp&apos;), //本地安装gulp所用到的地方</div><div class="line">    less = require(&apos;gulp-less&apos;);</div><div class="line"> </div><div class="line">//定义一个testLess任务（自定义任务名称）</div><div class="line">gulp.task(&apos;testLess&apos;, function () &#123;</div><div class="line">    gulp.src(&apos;src/less/index.less&apos;) //该任务针对的文件</div><div class="line">        .pipe(less()) //该任务调用的模块</div><div class="line">        .pipe(gulp.dest(&apos;src/css&apos;)); //将会在src/css下生成index.css</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">gulp.task(&apos;default&apos;,[&apos;testLess&apos;, &apos;elseTask&apos;]); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务</div><div class="line"> </div><div class="line">//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数</div><div class="line">//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) </div><div class="line">//gulp.dest(path[, options]) 处理完后文件生成路径</div></pre></td></tr></table></figure>
<h4 id="9、运行gulp"><a href="#9、运行gulp" class="headerlink" title="9、运行gulp"></a>9、运行gulp</h4><p>9.1、说明：命令提示符执行gulp 任务名称；<br>9.2、编译less：命令提示符执行gulp testLess；<br>9.3、当执行gulp default或gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’]。</p>
<h4 id="10、使用webstorm运行gulp任务"><a href="#10、使用webstorm运行gulp任务" class="headerlink" title="10、使用webstorm运行gulp任务"></a>10、使用webstorm运行gulp任务</h4><p>10.1、说明：使用webstorm可视化运行gulp任务；<br>10.2、使用方法：将项目导入webstorm，右键gulpfile.js 选择”Show Gulp Tasks”打开Gulp窗口，若出现”No task found”，选择右键”Reload tasks”，双击运行即可。<br><img src="http://img.blog.csdn.net/20170103211004745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="webpack-amp-gulp集成"><a href="#webpack-amp-gulp集成" class="headerlink" title="webpack&amp;gulp集成"></a>webpack&amp;gulp集成</h2><p>接下来要到重点了，gulp和webpack各有各的优点，那么我们整合这两个工具呢？</p>
<h3 id="创建webpack对象"><a href="#创建webpack对象" class="headerlink" title="创建webpack对象"></a>创建webpack对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var webpack = require(&quot;webpack&quot;)</div></pre></td></tr></table></figure>
<h3 id="创建gulp任务"><a href="#创建gulp任务" class="headerlink" title="创建gulp任务"></a>创建gulp任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//gulp --product</div><div class="line">gulp.task(&apos;default&apos;, function() &#123;</div><div class="line">  isProduct = argv.product;</div><div class="line">  isWatch = !isProduct;</div><div class="line">  console.log(&apos;正在处理：&apos; + (isProduct ? &apos;线上&apos; : &apos;本地&apos;) + &apos;环境&apos;);</div><div class="line">  fse.emptydirSync(&apos;./dist&apos;);</div><div class="line">  gulp.start(&apos;webpack&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ps:本地开发(命令：gulp)和线上(命令：gulp –product)部署gulp命令分开，本地会做文件更改的监听，并且不会压缩。</p>
<h3 id="webpack任务配置"><a href="#webpack任务配置" class="headerlink" title="webpack任务配置"></a>webpack任务配置</h3><p>入口文件配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">            index: &apos;./index.js&apos;</div><div class="line">            common: [</div><div class="line">                &apos;jquery&apos;,</div><div class="line">                &apos;understore&apos;,</div><div class="line">                &apos;template&apos;,</div><div class="line">                &apos;store&apos;</div><div class="line">            ]</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>该参数主要是配置入口文件，打包出来的文件就是以里面的key作为名字的文件（即bundle）。<br>输出路径配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">            path: &apos;./dist/&apos;,</div><div class="line">            filename: &apos;[name].js&apos;,</div><div class="line">            publicPath: &apos;&apos;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>别名配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">            alias: &#123;</div><div class="line">                jquery: path.resolve(&apos;../global/lib/jquery.js&apos;),</div><div class="line">                template: path.resolve(&apos;../global/lib/template.js&apos;),</div><div class="line">                understore: path.resolve(&apos;../global/lib/underscore.js&apos;),</div><div class="line">                store: path.resolve(&apos;../global/lib/store.js&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>配置完别名，就可以用别名来进行require了，不管是在webpack配置中，还是在js代码中。</p>
<h3 id="webpack插件配置"><a href="#webpack插件配置" class="headerlink" title="webpack插件配置"></a>webpack插件配置</h3><p>webpack内部全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new webpack.ProvidePlugin(&#123;</div><div class="line">    $: &apos;jquery&apos;,</div><div class="line">    jQuery: &apos;jquery&apos;,</div><div class="line">    template: &apos;template&apos;,</div><div class="line">    store: &apos;store&apos;,</div><div class="line">    _: &apos;understore&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>配置完全局的变量，在js中就直接可以用，不需要再require。该全局不是挂载到window对象上，只对webpack打包出来的js有用。<br>合并相同的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.DedupePlugin()</div></pre></td></tr></table></figure>
<p>说明:该插件会把相同的模块合并，不推荐使用，最好自己做到模块唯一性，如果打出来两个相同的模块，说明你的代码潜藏出错风险。<br>css抽离插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ExtractTextPlugin(&quot;[name].css&quot;)</div></pre></td></tr></table></figure>
<p>该插件会把css抽离出来作为单独的css文件进行打包，如果不使用该插件，会把css打包到js中，然后以style标签的形式，把css作为内联样式使用。<br>公共文件插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.CommonsChunkPlugin(&apos;common&apos;, &apos;common.js&apos;)</div></pre></td></tr></table></figure>
<p>该插件会把公共的模块进行抽离到公共的js模块里面，防止js重复引用打包。<br>压缩插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        compress: &#123;</div><div class="line">            warnings: false</div><div class="line">        &#125;,</div><div class="line">        mangle: &#123;</div><div class="line">            except: [&apos;$&apos;, &apos;m&apos;, &apos;webpackJsonpCallback&apos;]</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>该插件会把js进行压缩，在线上环境进行使用。<br>注：mangle该关键词不需要混淆，因为在我们实践过程中，压缩后的代码有很多地方报错。<br>由于webpack会把所有的js都打包到一个js文件中，这样就不方便开发人员debug，故需要进行sourcemap的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devtool: (isProduct ? false : &apos;source-map&apos;)</div></pre></td></tr></table></figure>
<h3 id="加载器loader"><a href="#加载器loader" class="headerlink" title="加载器loader"></a>加载器loader</h3><p>js加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.js[x]?$/,</div><div class="line">    exclude: /node_modules/,</div><div class="line">    loader: &apos;babel-loader&apos;,</div><div class="line">    query: &#123;</div><div class="line">        compact: false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>js使用babel来进行加载，这样就可以使用一些es6的特性来开发，IE8下面使用如下方案来进行解决转换后的代码不兼容问题。</p>
<p>ps：解决IE8 babel 转换：我们把shim.js &amp; sham.js，自己合并到一起吧。<br>css、less、sass加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.css$/,</div><div class="line">    loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues&apos;)</div><div class="line">&#125;, &#123;</div><div class="line">    test: /\.less$/,</div><div class="line">    loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!less-loader&apos;)</div><div class="line">&#125;, &#123;</div><div class="line">    test: /\.scss$/,</div><div class="line">    loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!sass-loader&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ExtractTextPlugin是抽离css的插件。css-loader是处理css，会把url(xxx.png)处理成require，然后通过对应后缀名的其他加载器进行处理。==如果是线上环境，css会进行压缩，很多配置要进行调整如果直接采用默认的，转换后的css会出现一些问题，常见问题如：</p>
<ul>
<li>问题一，压缩后字体文件不能处理。解决方法：把iconfont.css里面的注释删除掉即可</li>
<li>问题二，压缩后的px单位会转换成pc,pt。解决方法：在加载器里面加上-convertValues参数。</li>
<li>问题三，css require的优先级问题，按照常理是后require的css是后加载。但是在实践过程中，(1)通过import引入的js模块中引入的css是优先于require引入的js模块中引入的css；(2)js中require的css名称如果和js所在模块的文件夹名字相同即使部分相同的话，优先级也会提高。</li>
<li>关于更多的问题请参照Loader配置。<br>图片字体文件加载器，file-loader：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.(png|jpg|gif|woff|woff2|ttf|eot|svg)$/,</div><div class="line">    loader: &quot;file-loader?name=[name]_[sha512:hash:base64:7].[ext]&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对一些图片和字体资源进行加载，我们会把相关文件抽离出来进行名字加上hash值的前7位做了处理后的名字。<br>html加载器;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.html/,</div><div class="line">    loader: &quot;html-loader&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="gulp脚本文件-重要"><a href="#gulp脚本文件-重要" class="headerlink" title="gulp脚本文件(重要)"></a>gulp脚本文件(重要)</h3><p>gulpfile.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;),</div><div class="line">    argv = require(&apos;yargs&apos;).argv,</div><div class="line">    fs = require(&apos;fs&apos;),</div><div class="line">    fse = require(&apos;fs-extra&apos;),</div><div class="line">    path = require(&apos;path&apos;),</div><div class="line">    util = require(&apos;util&apos;);</div><div class="line">var webpack = require(&quot;webpack&quot;),</div><div class="line">    ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class="line"></div><div class="line">var isWatch = true;</div><div class="line">var isProduct = false;</div><div class="line">var project = &apos;iwjw-pc&apos;;</div><div class="line">//gulp --product</div><div class="line">gulp.task(&apos;default&apos;, function() &#123;</div><div class="line">    isProduct = argv.product;</div><div class="line">    isWatch = !isProduct;</div><div class="line"></div><div class="line">    console.log(&apos;正在处理：&apos; + (isProduct ? &apos;线上&apos; : &apos;本地&apos;) + &apos;环境&apos;);</div><div class="line"></div><div class="line">    fse.emptydirSync(&apos;./dist&apos;);</div><div class="line"></div><div class="line">    gulp.start(&apos;webpack&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//webpack静态处理</div><div class="line">gulp.task(&apos;webpack&apos;, function(callback) &#123;</div><div class="line">    var minfy = [];</div><div class="line">    isProduct &amp;&amp; minfy.push(new webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        compress: &#123;</div><div class="line">            warnings: false</div><div class="line">        &#125;,</div><div class="line">        mangle: &#123;</div><div class="line">            except: [&apos;$&apos;, &apos;m&apos;, &apos;webpackJsonpCallback&apos;]</div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    //webpack配置文件</div><div class="line">    var config = &#123;</div><div class="line">        watch: isWatch,</div><div class="line">        entry: &#123;</div><div class="line">            index: &apos;./index.js&apos;,</div><div class="line">            common: [</div><div class="line">                &apos;jquery&apos;,</div><div class="line">                &apos;understore&apos;,</div><div class="line">                &apos;template&apos;,</div><div class="line">                &apos;store&apos;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        debug: true,</div><div class="line"></div><div class="line">        devtool: (isProduct ? false : &apos;source-map&apos;),</div><div class="line"></div><div class="line">        output: &#123;</div><div class="line">            path: &apos;./dist/&apos;,</div><div class="line">            filename: &apos;[name].js&apos;,</div><div class="line">            publicPath: &apos;&apos;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        resolve: &#123;</div><div class="line">            alias: &#123;</div><div class="line">                jquery: path.resolve(&apos;../global/lib/jquery.js&apos;),</div><div class="line">                template: path.resolve(&apos;../global/lib/template.js&apos;),</div><div class="line">                understore: path.resolve(&apos;../global/lib/underscore.js&apos;),</div><div class="line">                store: path.resolve(&apos;../global/lib/store.js&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line"></div><div class="line">        plugins: [</div><div class="line">            new webpack.ProvidePlugin(&#123;</div><div class="line">                $: &apos;jquery&apos;,</div><div class="line">                jQuery: &apos;jquery&apos;,</div><div class="line">                template: &apos;template&apos;,</div><div class="line">                store: &apos;store&apos;,</div><div class="line">                _: &apos;understore&apos;</div><div class="line">            &#125;),</div><div class="line">            new webpack.optimize.DedupePlugin(),</div><div class="line">            new ExtractTextPlugin(&quot;[name].css&quot;),</div><div class="line">            new webpack.optimize.CommonsChunkPlugin(&apos;common&apos;, &apos;common.js&apos;)</div><div class="line">        ].concat(minfy),</div><div class="line">        module: &#123;</div><div class="line">            loaders: [&#123;</div><div class="line">                test: /\.js[x]?$/,</div><div class="line">                exclude: /node_modules/,</div><div class="line">                loader: &apos;babel-loader&apos;,</div><div class="line">                query: &#123;</div><div class="line">                    compact: false</div><div class="line">                &#125;</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues&apos;)</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.less$/,</div><div class="line">                loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!less-loader&apos;)</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.scss$/,</div><div class="line">                loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!sass-loader&apos;)</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.(png|jpg|gif|woff|woff2|ttf|eot|svg)$/,</div><div class="line">                loader: &quot;file-loader?name=[name]_[sha512:hash:base64:7].[ext]&quot;</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.html/,</div><div class="line">                loader: &quot;html-loader&quot;</div><div class="line">            &#125;]</div><div class="line">        &#125;</div><div class="line">    &#125;; </div><div class="line">    webpack(config, function(err, stats) &#123;</div><div class="line">        console.log(stats.toString());</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">gulp.task(&apos;sham&apos;, function()&#123;</div><div class="line">    gulp.src(&apos;../global/lib/es5-shim-sham.js&apos;).pipe(gulp.dest(&apos;./dist&apos;));</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>pacakge.json（根据项目情况配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;name&quot;: &quot;iwfe&quot;,</div><div class="line">&quot;version&quot;: &quot;0.0.0&quot;,</div><div class="line">&quot;private&quot;: true,</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;start&quot;: &quot;node ./bin/server&quot;</div><div class="line">&#125;,</div><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">  &quot;babel-loader&quot;: &quot;^5.3.2&quot;,</div><div class="line">  &quot;bundle-loader&quot;: &quot;^0.5.4&quot;,</div><div class="line">  &quot;css-loader&quot;: &quot;^0.16.0&quot;,</div><div class="line">  &quot;exports-loader&quot;: &quot;^0.6.2&quot;,</div><div class="line">  &quot;extract-text-webpack-plugin&quot;: &quot;^0.8.2&quot;,</div><div class="line">  &quot;file-loader&quot;: &quot;~0.8.4&quot;,</div><div class="line">  &quot;fs-extra&quot;: &quot;*&quot;,</div><div class="line">  &quot;html-loader&quot;: &quot;^0.4.0&quot;,</div><div class="line">  &quot;imports-loader&quot;: &quot;^0.6.5&quot;,</div><div class="line">  &quot;jquery&quot;: &quot;~2.1.4&quot;,</div><div class="line">  &quot;sass-loader&quot;: &quot;^3.1.2&quot;,</div><div class="line">  &quot;source-map-loader&quot;: &quot;^0.1.5&quot;,</div><div class="line">  &quot;style-loader&quot;: &quot;~0.12.3&quot;,</div><div class="line">  &quot;through2&quot;: &quot;*&quot;,</div><div class="line">  &quot;url-loader&quot;: &quot;~0.5.6&quot;,</div><div class="line">  &quot;webpack&quot;: &quot;*&quot;,</div><div class="line">  &quot;webpack-dev-server&quot;: &quot;^1.10.1&quot;,</div><div class="line">  &quot;yargs&quot;: &quot;*&quot;,</div><div class="line">  &quot;gulp-zip&quot;: &quot;*&quot;</div><div class="line">&#125;,</div><div class="line">&quot;devDependencies&quot;: &#123;</div><div class="line">  &quot;gulp&quot;: &quot;*&quot;,</div><div class="line">  &quot;gulp-util&quot;: &quot;*&quot;</div><div class="line">&#125;,</div><div class="line">&quot;description&quot;: &quot;前端静态库&quot;,</div><div class="line">&quot;repository&quot;: &#123;</div><div class="line">  &quot;type&quot;: &quot;git&quot;,</div><div class="line">  &quot;url&quot;: &quot;xxx&quot;</div><div class="line">&#125;,</div><div class="line">&quot;author&quot;: &quot;jade&quot;,</div><div class="line">&quot;license&quot;: &quot;ISC&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：<a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">http://www.ydcss.com/archives/18</a><br><a href="https://github.com/webpack" target="_blank" rel="external">https://github.com/webpack</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;webpack简介&quot;&gt;&lt;a href=&quot;#webpack简介&quot; class=&quot;headerlink&quot; title=&quot;webpack简介&quot;&gt;&lt;/a&gt;webpack简介&lt;/h2&gt;&lt;p&gt;Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="webpack" scheme="http://www.xiangzhihong.com/tags/webpack/"/>
    
      <category term="gulp" scheme="http://www.xiangzhihong.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>Angular2入坑指南</title>
    <link href="http://www.xiangzhihong.com/2016/12/05/Angular2%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://www.xiangzhihong.com/2016/12/05/Angular2入坑指南/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-07-10T01:05:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>对后端开发来说，前端是神秘的，眼花缭乱的技术，繁多的框架，出名的不出名的好几百种，看是“繁荣”，其实显得杂乱无章，但是我们在做开发的时候，技术选型还是主流的那么几个：浅析angular，react，vue.js Node.js。</p>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>官网：<a href="https://nodejs.org/" target="_blank" rel="external">https://nodejs.org/</a><br>nodejs不是一个js框架，千万不要认为是类似jquery的框架，nodejs是js运行时，运行环境，类比java中jvm。做前端的没用过nodejs都不好意思说自己是前端。nodejs是和jvm同等地位的js运行环境，打开了前端人员走向后端的道路。</p>
<h2 id="react-js"><a href="#react-js" class="headerlink" title="react.js"></a>react.js</h2><p>官网：<a href="http://facebook.github.io/react/" target="_blank" rel="external">http://facebook.github.io/react/</a><br>react是facebook前不久出的一款框架，众前端膜拜之。类比Java中freemarker的宏。reactjs最大的作用就是用来开发ui组件，比如用它开发移动端页面，也是今年移动端前端化的推动者。</p>
<h2 id="angular-js"><a href="#angular-js" class="headerlink" title="angular.js"></a>angular.js</h2><p>官网：<a href="http://www.apjs.net/" target="_blank" rel="external">http://www.apjs.net/</a><br>angular是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。因为背靠google也收到了开发者的推崇。</p>
<h1 id="概念与区别"><a href="#概念与区别" class="headerlink" title="概念与区别"></a>概念与区别</h1><p>本人也在React与Angular两大体系里纠结了好久，还使用React Native做了几个UI，彷徨于两大前端框架之前。<br>React缺点：</p>
<ol>
<li>Web Componet的MVC分离不够彻底。 JSX描述的页面模板与JS代码没有办法完全分开。<br>无法接受代码的同时还夹个HTML代码这样原始的方式。</li>
<li>对UI的描述自成一体，而不是采用CSS或者SCSS。</li>
<li>数据的传递不够直接还有一堆乱七八槽的属性</li>
<li>Android与IOS的代码不够一致</li>
<li>核心太小，一堆补充的库<br>Angular2的优点：<br>1、推荐TypeScript而不是原生的Javascript<br>2、类库特别多，概念也是特别多<br>3、体量大<br>4、成熟度相对偏低，版本2才刚发布<br>5、不兼容1.x<br>6、Router还不成熟<br>综合以上我最终决定选择Angular2作为我前端开发的首选框架。<br>同时还有以下几个Bonus：</li>
<li>配置nativescript写原生应用，并且nativescript支持css子集，这一点比react要强一些，可以更小的降低学习成本与维护成本。<ol>
<li>有官方的UI方案Material Design供选择</li>
<li>官工具链相对于React要成熟 有angular-cli这个便利化的工具，并提供E2E的测试，用以方便测试，并保证项目的质量。</li>
<li>维护团队强大<br>来看一张图：<br><img src="http://img.blog.csdn.net/20161225121233493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h1 id="Angular2快速安装与入门"><a href="#Angular2快速安装与入门" class="headerlink" title="Angular2快速安装与入门"></a>Angular2快速安装与入门</h1>安装angular-cli</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g angular-cli</div></pre></td></tr></table></figure>
<p>创建项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ng new PROJECT_NAMEcd PROJECT_NAMEng serve</div></pre></td></tr></table></figure>
<p>就这么 简单，这时候你的项目已经运行起来了。<br><img src="http://img.blog.csdn.net/20161225121618854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>我们看一下项目结构<br><img src="http://img.blog.csdn.net/20161225121652321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后打开localhost:4200就可以查看效果了。<br>附：<a href="https://github.com/angular/angular-cli" target="_blank" rel="external">angular-cli的教程与源码地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;对后端开发来说，前端是神秘的，眼花缭乱的技术，繁多的框架，出名的不出名的好几百种，看是“繁荣”，其实显得杂乱无章，但是我们在做开发的时候，技术选型还
    
    </summary>
    
      <category term="Angular2" scheme="http://www.xiangzhihong.com/categories/Angular2/"/>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/Angular2/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Angular2" scheme="http://www.xiangzhihong.com/tags/Angular2/"/>
    
      <category term="前端开发" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://www.xiangzhihong.com/2016/12/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.xiangzhihong.com/2016/12/01/机器学习/</id>
    <published>2016-11-30T16:00:00.000Z</published>
    <updated>2017-07-10T01:30:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>什么是机器学习？<br>机器学习是英文名称Machine Learning(简称ML)的直译。机器学习涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。<br>相对于传统的计算机工作，我们给它一串指令，然后它遵照这个指令一步步执行下去即可。机器学习根本不接受你输入的指令，相反，它只接受你输入的数据!也就是说它某种意义上具有了我们人处理事情的能力。</p>
<h2 id="机器学习发展史"><a href="#机器学习发展史" class="headerlink" title="机器学习发展史"></a>机器学习发展史</h2><p>机器学习是人工智能研究较为年轻的分支，它的发展过程大体上可分为4个时期。<br>第一阶段是在20世纪50年代中叶到60年代中叶，属于热烈时期。<br>第二阶段是在20世纪60年代中叶至70年代中叶，被称为机器学习的冷静时期。<br>第三阶段是从20世纪70年代中叶至80年代中叶，称为复兴时期。<br>机器学习的最新阶段始于1986年。机器学习进入新阶段的重要表现在下列诸方面：<br>(1) 机器学习已成为新的边缘学科并在高校形成一门课程。它综合应用心理学、生物学和神经生理学以及数学、自动化和计算机科学形成机器学习理论基础。<br>(2) 结合各种学习方法，取长补短的多种形式的集成学习系统研究正在兴起。特别是连接学习符号学习的耦合可以更好地解决连续性信号处理中知识与技能的获取与求精问题而受到重视。<br>(3) 机器学习与人工智能各种基础问题的统一性观点正在形成。例如学习与问题求解结合进行、知识表达便于学习的观点产生了通用智能系统SOAR的组块学习。类比学习与问题求解结合的基于案例方法已成为经验学习的重要方向。<br>(4) 各种学习方法的应用范围不断扩大，一部分已形成商品。归纳学习的知识获取工具已在诊断分类型专家系统中广泛使用。连接学习在声图文识别中占优势。分析学习已用于设计综合型专家系统。遗传算法与强化学习在工程控制中有较好的应用前景。与符号系统耦合的神经网络连接学习将在企业的智能管理与智能机器人运动规划中发挥作用。<br>(5) 与机器学习有关的学术活动空前活跃。国际上除每年一次的机器学习研讨会外，还有计算机学习理论会议以及遗传算法会议。</p>
<h2 id="机器学习的范围"><a href="#机器学习的范围" class="headerlink" title="机器学习的范围"></a>机器学习的范围</h2><p>机器学习跟模式识别，统计学习，数据挖掘，计算机视觉，语音识别，自然语言处理等领域有着很深的联系。从范围上来说，机器学习跟模式识别，统计学习，数据挖掘是类似的，同时，机器学习与其他领域的处理技术的结合，形成了计算机视觉、语音识别、自然语言处理等交叉学科。因此，一般说数据挖掘时，可以等同于说机器学习。同时，我们平常所说的机器学习应用，应该是通用的，不仅仅局限在结构化数据，还有图像，音频等应用。</p>
<h3 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h3><p>模式识别=机器学习。两者的主要区别在于前者是从工业界发展起来的概念，后者则主要源自计算机学科。在著名的《Pattern Recognition And Machine Learning》这本书中，Christopher M. Bishop在开头是这样说的“模式识别源自工业界，而机器学习来自于计算机学科。不过，它们中的活动可以被视为同一个领域的两个方面，同时在过去的10年间，它们都有了长足的发展”。</p>
<h3 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h3><p>数据挖掘=机器学习+数据库，记得大学的最后一学期开了一门数据挖掘的课，何为数据挖掘，就是从海量的数据中挖掘出有用的数据，其实从某种意义上来说和大数据分析很像。数据挖掘通常与计算机科学有关，并通过统计、在线分析处理、情报检索、机器学习、专家系统（依靠过去的经验法则）和模式识别等诸多方法来实现上述目标。</p>
<h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><p>统计学习近似等于机器学习。统计学习是个与机器学习高度重叠的学科。因为机器学习中的大多数方法来自统计学，甚至可以认为，统计学的发展促进机器学习的繁荣昌盛。例如著名的支持向量机算法，就是源自统计学科。但是在某种程度上两者是有分别的，这个分别在于：统计学习者重点关注的是统计模型的发展与优化，偏数学，而机器学习者更关注的是能够解决问题，偏实践，因此机器学习研究者会重点研究学习算法在计算机上执行的效率与准确性的提升。</p>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>计算机视觉=图像处理+机器学习。图像处理技术用于将图像处理为适合进入机器学习模型中的输入，机器学习则负责从图像中识别出相关的模式。随着机器学习的新领域深度学习的发展，大大促进了计算机图像识别的效果，因此未来计算机视觉界的发展前景不可估量。</p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>语音识别=语音处理+机器学习。语音识别就是音频处理技术与机器学习的结合。语音识别技术一般不会单独使用，一般会结合自然语言处理的相关技术。目前的相关应用有苹果的语音助手siri，讯飞等国内很多的科技公司和机构。</p>
<h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>自然语言处理=文本处理+机器学习。自然语言处理技术主要是让机器理解人类的语言的一门领域。在自然语言处理技术中，大量使用了编译原理相关的技术，例如词法分析，语法分析等等，除此之外，在理解这个层面，则使用了语义理解，机器学习等技术。</p>
<h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><h3 id="监督式学习"><a href="#监督式学习" class="headerlink" title="监督式学习"></a>监督式学习</h3><p>监督式学习算法包括一个目标变量（因变量）和用来预测目标变量的预测变量（自变量）。通过这些变量我们可以搭建一个模型，从而对于一个已知的预测变量值，我们可以得到对应的目标变量值。重复训练这个模型，直到它能在训练数据集上达到预定的准确度。 属于监督式学习的算法有：回归模型，决策树，随机森林，K邻近算法，逻辑回归等。</p>
<h3 id="无监督式学习"><a href="#无监督式学习" class="headerlink" title="无监督式学习"></a>无监督式学习</h3><p>与监督式学习不同的是，无监督学习中我们没有需要预测或估计的目标变量。无监督式学习是用来对总体对象进行分类的。它在根据某一指标将客户分类上有广泛应用。 属于无监督式学习的算法有：关联规则，K-means聚类算法等。</p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。 属于这一类算法的有马尔可夫决策过程。</p>
<h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>常见的机器学习算法<br>以下是最常用的机器学习算法，大部分数据问题都可以通过它们解决：<br>1.线性回归 (Linear Regression)<br>2.逻辑回归 (Logistic Regression)<br>3.决策树 (Decision Tree)<br>4.支持向量机（SVM）<br>5.朴素贝叶斯 (Naive Bayes)<br>6.K邻近算法（KNN）<br>7.K-均值算法（K-means）<br>8.随机森林 (Random Forest)<br>9.降低维度算法（DimensionalityReduction Algorithms）<br>10.GradientBoost和Adaboost算法</p>
<h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><h3 id="基于学习策略的分类"><a href="#基于学习策略的分类" class="headerlink" title="基于学习策略的分类"></a>基于学习策略的分类</h3><p>学习策略是指学习过程中系统所采用的推理策略。一个学习系统总是由学习和环境两部分组成。由环境（如书本或教师）提供信息，学习部分则实现信息转换，用能够理解的形式记忆下来，并从中获取有用的信息。在学习过程中，学生（学习部分）使用的推理越少，他对教师（环境）的依赖就越大，教师的负担也就越重。学习策略的分类标准就是根据学生实现信息转换所需的推理多少和难易程度来分类的，依从简单到复杂，从少到多的次序分为以下六种基本类型：</p>
<h4 id="1）机械学习-Rote-learning"><a href="#1）机械学习-Rote-learning" class="headerlink" title="1）机械学习 (Rote learning)"></a>1）机械学习 (Rote learning)</h4><p>学习者无需任何推理或其它的知识转换，直接吸取环境所提供的信息。如塞缪尔的跳棋程序，纽厄尔和西蒙的LT系统。这类学习系统主要考虑的是如何索引存贮的知识并加以利用。系统的学习方法是直接通过事先编好、构造好的程序来学习，学习者不作任何工作，或者是通过直接接收既定的事实和数据进行学习，对输入信息不作任何的推理。</p>
<h4 id="2）示教学习-Learning-from-instruction或Learning-by-being-told"><a href="#2）示教学习-Learning-from-instruction或Learning-by-being-told" class="headerlink" title="2）示教学习 (Learning from instruction或Learning by being told)"></a>2）示教学习 (Learning from instruction或Learning by being told)</h4><p>学生从环境（教师或其它信息源如教科书等）获取信息，把知识转换成内部可使用的表示形式，并将新的知识和原有知识有机地结合为一体。所以要求学生有一定程度的推理能力，但环境仍要做大量的工作。教师以某种形式提出和组织知识，以使学生拥有的知识可以不断地增加。这种学习方法和人类社会的学校教学方式相似，学习的任务就是建立一个系统，使它能接受教导和建议，并有效地存贮和应用学到的知识。不少专家系统在建立知识库时使用这种方法去实现知识获取。示教学习的一个典型应用例是FOO程序。</p>
<h4 id="3）演绎学习-Learning-by-deduction"><a href="#3）演绎学习-Learning-by-deduction" class="headerlink" title="3）演绎学习 (Learning by deduction)"></a>3）演绎学习 (Learning by deduction)</h4><p>学生所用的推理形式为演绎推理。推理从公理出发，经过逻辑变换推导出结论。这种推理是”保真”变换和特化(specialization)的过程，使学生在推理过程中可以获取有用的知识。这种学习方法包含宏操作(macro-operation)学习、知识编辑和组块(Chunking)技术。演绎推理的逆过程是归纳推理。</p>
<h4 id="4）类比学习-Learning-by-analogy"><a href="#4）类比学习-Learning-by-analogy" class="headerlink" title="4）类比学习 (Learning by analogy)"></a>4）类比学习 (Learning by analogy)</h4><p>利用二个不同领域（源域、目标域）中的知识相似性，可以通过类比，从源域的知识（包括相似的特征和其它性质）推导出目标域的相应知识，从而实现学习。类比学习系统可以使一个已有的计算机应用系统转变为适应于新的领域，来完成原先没有设计的相类似的功能。<br>类比学习需要比上述三种学习方式更多的推理。它一般要求先从知识源（源域）中检索出可用的知识，再将其转换成新的形式，用到新的状况（目标域）中去。类比学习在人类科学技术发展史上起着重要作用，许多科学发现就是通过类比得到的。例如著名的卢瑟福类比就是通过将原子结构（目标域）同太阳系（源域）作类比，揭示了原子结构的奥秘。</p>
<h4 id="5）基于解释的学习-Explanation-based-learning-EBL"><a href="#5）基于解释的学习-Explanation-based-learning-EBL" class="headerlink" title="5）基于解释的学习 (Explanation-based learning, EBL)"></a>5）基于解释的学习 (Explanation-based learning, EBL)</h4><p>学生根据教师提供的目标概念、该概念的一个例子、领域理论及可操作准则，首先构造一个解释来说明为什该例子满足目标概念，然后将解释推广为目标概念的一个满足可操作准则的充分条件。EBL已被广泛应用于知识库求精和改善系统的性能。<br>著名的EBL系统有迪乔恩（G.DeJong）的GENESIS,米切尔（T.Mitchell）的LEXII和LEAP, 以及明顿（S.Minton）等的PRODIGY。</p>
<h4 id="6）归纳学习-Learning-from-induction"><a href="#6）归纳学习-Learning-from-induction" class="headerlink" title="6）归纳学习 (Learning from induction)"></a>6）归纳学习 (Learning from induction)</h4><p>归纳学习是由教师或环境提供某概念的一些实例或反例，让学生通过归纳推理得出该概念的一般描述。这种学习的推理工作量远多于示教学习和演绎学习，因为环境并不提供一般性概念描述（如公理）。从某种程度上说，归纳学习的推理量也比类比学习大，因为没有一个类似的概念可以作为”源概念”加以取用。归纳学习是最基本的，发展也较为成熟的学习方法，在人工智能领域中已经得到广泛的研究和应用。</p>
<h3 id="基于所获取知识的表示形式分类"><a href="#基于所获取知识的表示形式分类" class="headerlink" title="基于所获取知识的表示形式分类　"></a>基于所获取知识的表示形式分类　</h3><p>学习系统获取的知识可能有：行为规则、物理对象的描述、问题求解策略、各种分类及其它用于任务实现的知识类型。<br>对于学习中获取的知识，主要有以下一些表示形式：</p>
<h4 id="1）代数表达式参数"><a href="#1）代数表达式参数" class="headerlink" title="1）代数表达式参数"></a>1）代数表达式参数</h4><p>学习的目标是调节一个固定函数形式的代数表达式参数或系数来达到一个理想的性能。</p>
<h4 id="2）决策树"><a href="#2）决策树" class="headerlink" title="2）决策树"></a>2）决策树</h4><p>用决策树来划分物体的类属，树中每一内部节点对应一个物体属性，而每一边对应于这些属性的可选值，树的叶节点则对应于物体的每个基本分类。</p>
<h4 id="3）形式文法"><a href="#3）形式文法" class="headerlink" title="3）形式文法"></a>3）形式文法</h4><p>在识别一个特定语言的学习中，通过对该语言的一系列表达式进行归纳，形成该语言的形式文法。</p>
<h4 id="4）产生式规则"><a href="#4）产生式规则" class="headerlink" title="4）产生式规则"></a>4）产生式规则</h4><p>产生式规则表示为条件—动作对，已被极为广泛地使用。学习系统中的学习行为主要是：生成、泛化、特化（Specialization）或合成产生式规则。</p>
<h4 id="5）形式逻辑表达式"><a href="#5）形式逻辑表达式" class="headerlink" title="5）形式逻辑表达式"></a>5）形式逻辑表达式</h4><p>形式逻辑表达式的基本成分是命题、谓词、变量、约束变量范围的语句，及嵌入的逻辑表达式。</p>
<h4 id="6）图和网络"><a href="#6）图和网络" class="headerlink" title="6）图和网络"></a>6）图和网络</h4><p>有的系统采用图匹配和图转换方案来有效地比较和索引知识。</p>
<h4 id="7）框架和模式（schema）"><a href="#7）框架和模式（schema）" class="headerlink" title="7）框架和模式（schema）"></a>7）框架和模式（schema）</h4><p>每个框架包含一组槽，用于描述事物（概念和个体）的各个方面。</p>
<h4 id="8）计算机程序和其它的过程编码"><a href="#8）计算机程序和其它的过程编码" class="headerlink" title="8）计算机程序和其它的过程编码"></a>8）计算机程序和其它的过程编码</h4><p>获取这种形式的知识，目的在于取得一种能实现特定过程的能力，而不是为了推断该过程的内部结构。</p>
<h4 id="9）神经网络"><a href="#9）神经网络" class="headerlink" title="9）神经网络"></a>9）神经网络</h4><p>这主要用在联接学习中。学习所获取的知识，最后归纳为一个神经网络。</p>
<h4 id="10）多种表示形式的组合"><a href="#10）多种表示形式的组合" class="headerlink" title="10）多种表示形式的组合"></a>10）多种表示形式的组合</h4><p>根据表示的精细程度，可将知识表示形式分为两大类：泛化程度高的粗粒度符号表示、??泛化程度低的精粒度亚符号(sub-symbolic)表示。像决策树、形式文法、产生式规则、形式逻辑表达式、框架和模式等属于符号表示类；而代数表达式参数、图和网络、神经网络等则属亚符号表示类。</p>
<h3 id="按应用领域分类"><a href="#按应用领域分类" class="headerlink" title="按应用领域分类　"></a>按应用领域分类　</h3><p>最主要的应用领域有：专家系统、认知模拟、规划和问题求解、数据挖掘、网络信息服务、图象识别、故障诊断、自然语言理解、机器人和博弈等领域。<br>从机器学习的执行部分所反映的任务类型上看，大部分的应用研究领域基本上集中于以下两个范畴：分类和问题求解。<br>（1）分类任务要求系统依据已知的分类知识对输入的未知模式（该模式的描述）作分析，以确定输入模式的类属。相应的学习目标就是学习用于分类的准则（如分类规则）。<br>（2）问题求解任务要求对于给定的目标状态,??寻找一个将当前状态转换为目标状态的动作序列；机器学习在这一领域的研究工作大部分集中于通过学习来获取能提高问题求解效率的知识（如搜索控制知识，启发式知识等）。</p>
<h3 id="综合分类"><a href="#综合分类" class="headerlink" title="综合分类"></a>综合分类</h3><h4 id="1）经验性归纳学习-empirical-inductive-learning"><a href="#1）经验性归纳学习-empirical-inductive-learning" class="headerlink" title="1）经验性归纳学习 (empirical inductive learning)"></a>1）经验性归纳学习 (empirical inductive learning)</h4><p>经验性归纳学习采用一些数据密集的经验方法（如版本空间法、ID3法，定律发现方法）对例子进行归纳学习。其例子和学习结果一般都采用属性、谓词、关系等符号表示。它相当于基于学习策略分类中的归纳学习，但扣除联接学习、遗传算法、加强学习的部分。</p>
<h4 id="2）分析学习（analytic-learning）"><a href="#2）分析学习（analytic-learning）" class="headerlink" title="2）分析学习（analytic learning）"></a>2）分析学习（analytic learning）</h4><p>分析学习方法是从一个或少数几个实例出发，运用领域知识进行分析。其主要特征为：<br>·推理策略主要是演绎，而非归纳；<br>·使用过去的问题求解经验（实例）指导新的问题求解，或产生能更有效地运用领域知识的搜索控制规则。<br>分析学习的目标是改善系统的性能，而不是新的概念描述。分析学习包括应用解释学习、演绎学习、多级结构组块以及宏操作学习等技术。</p>
<h4 id="3）类比学习"><a href="#3）类比学习" class="headerlink" title="3）类比学习"></a>3）类比学习</h4><p>它相当于基于学习策略分类中的类比学习。在这一类型的学习中比较引人注目的研究是通过与过去经历的具体事例作类比来学习，称为基于范例的学习(case_based learning)，或简称范例学习。</p>
<h2 id="机器学习代码示例"><a href="#机器学习代码示例" class="headerlink" title="机器学习代码示例"></a>机器学习代码示例</h2><p>机器学习语音设计到pytho和R等最新语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//在gcc-4.7.2下编译通过。</div><div class="line">//命令行：g++-Wall-ansi-O2test.cpp-otest</div><div class="line">#include&lt;iostream&gt;</div><div class="line">usingnamespacestd;</div><div class="line">voidinput(int&amp;oper,constboolmeth)</div><div class="line">&#123;</div><div class="line">//meth为true则只判断1，为false则判断1或0</div><div class="line">while(true)</div><div class="line">&#123;</div><div class="line">cin&gt;&gt;oper;</div><div class="line">if(meth&amp;&amp;oper==1)</div><div class="line">break;</div><div class="line">elseif(oper==0||oper==1)</div><div class="line">break;</div><div class="line">cout&lt;&lt;&quot;输入错误，请重新输入。&quot;&lt;&lt;endl;//判断参数</div><div class="line">cin.sync();//避免极端输入导致死循环</div><div class="line">cin.clear();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">intmain(void)</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;&quot;1+1=2吗？那要看您怎么教我了，不要惊讶我会学习的&quot;&lt;&lt;endl;</div><div class="line">intladd,radd,aprs,rcnt(0),wcnt(0);//定义输入与结果，正确次数与错误次数</div><div class="line">cout&lt;&lt;&quot;开始学习……&quot;&lt;&lt;endl;</div><div class="line">for(inti(0);i!=10;++i)</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;&quot;参数1（必须是1）：&quot;&lt;&lt;flush;//提示输入参数</div><div class="line">input(ladd,true);</div><div class="line">cout&lt;&lt;&quot;参数2（必须是1）：&quot;&lt;&lt;flush;</div><div class="line">input(radd,true);</div><div class="line">cout&lt;&lt;&quot;结果：&quot;&lt;&lt;(ladd+radd)&lt;&lt;endl;//输出结果</div><div class="line">cout&lt;&lt;&quot;您对这满意吗（满意输入1，不满意输入0）：&quot;&lt;&lt;flush;//评价等级</div><div class="line">input(aprs,false);</div><div class="line">if(aprs)//判断用户评价</div><div class="line">++rcnt;</div><div class="line">else</div><div class="line">++wcnt;</div><div class="line">cout&lt;&lt;&quot;正确次数：&quot;&lt;&lt;rcnt&lt;&lt;&quot;错误次数：&quot;&lt;&lt;wcnt&lt;&lt;endl;//错误次数</div><div class="line">&#125;</div><div class="line">if(rcnt&gt;wcnt)//判断学习结果</div><div class="line">cout&lt;&lt;&quot;主人告诉我1+1=2。&quot;&lt;&lt;endl;</div><div class="line">else</div><div class="line">if(rcnt&lt;wcnt)</div><div class="line">cout&lt;&lt;&quot;主人告诉我1+1!=2。&quot;&lt;&lt;endl;</div><div class="line">else</div><div class="line">cout&lt;&lt;&quot;我不明白主人是什么意思。&quot;&lt;&lt;endl;</div><div class="line">intterm;//退出部分</div><div class="line">cout&lt;&lt;&quot;您对我的表现满意吗？满意请输入1不满意请输入0：&quot;&lt;&lt;flush;</div><div class="line">input(term,false);</div><div class="line">if(term)</div><div class="line">cout&lt;&lt;&quot;谢谢我会继续努力学习&quot;&lt;&lt;endl;</div><div class="line">else</div><div class="line">cout&lt;&lt;&quot;谢谢我会继续努力学习D&quot;&lt;&lt;endl;</div><div class="line">//cin&gt;&gt;term;//在Windows上测试时启用</div><div class="line">return0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;什么是机器学习？&lt;br&gt;机器学习是英文名称Machine Learning(简称ML)的直译。机器学习涉及概率论、统计学、逼近论、凸分析、算
    
    </summary>
    
      <category term="机器学习" scheme="http://www.xiangzhihong.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://www.xiangzhihong.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React Native和原生app通信机制详解</title>
    <link href="http://www.xiangzhihong.com/2016/11/18/React%20Native%E5%92%8C%E5%8E%9F%E7%94%9Fapp%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xiangzhihong.com/2016/11/18/React Native和原生app通信机制详解/</id>
    <published>2016-11-17T16:00:00.000Z</published>
    <updated>2017-07-10T01:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>React Native用iOS自带的JavaScriptCore作为JS的解析引擎，但并没有用到JavaScriptCore提供的一些可以让JS与OC互调的特性，而是自己实现了一套机制，这套机制可以通用于所有JS引擎上，在没有JavaScriptCore的情况下也可以用webview代替，实际上项目里就已经有了用webview作为解析引擎的实现，应该是用于兼容iOS7以下没有JavascriptCore的版本。<br>普通的JS-OC通信实际上很简单，OC向JS传信息有现成的接口，像webview提供的-stringByEvaluatingJavaScriptFromString方法可以直接在当前context上执行一段JS脚本，并且可以获取执行后的返回值，这个返回值就相当于JS向OC传递信息。React Native也是以此为基础，通过各种手段，实现了在OC定义一个模块方法，JS可以直接调用这个模块方法并还可以无缝衔接回调。<br>举个例子，OC定义了一个模块RCTSQLManager，里面有个方法-query:successCallback:，JS可以直接调用RCTSQLManager.query并通过回调获取执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//OC</div><div class="line">@implement RCTSQLManager</div><div class="line">- (void)query:(NSString *)queryData successCallback:(RCTResponseSenderBlOCk)responseSender</div><div class="line">&#123;</div><div class="line">     RCT_EXPORT();</div><div class="line">     NSString *ret = @&quot;ret&quot;</div><div class="line">     responseSender(ret);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//JS:</div><div class="line">RCTSQLManager.query(&quot;SELECT * FROM table&quot;, function(result) &#123;</div><div class="line">     //result == &quot;ret&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="模块配置表"><a href="#模块配置表" class="headerlink" title="模块配置表"></a>模块配置表</h1><p>首先OC要告诉JS它有什么模块，模块里有什么方法，JS才知道有这些方法后才有可能去调用这些方法。这里的实现是OC生成一份模块配置表传给JS，配置表里包括了所有模块和模块里方法的信息。例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;remoteModuleConfig&quot;: &#123;</div><div class="line">        &quot;RCTSQLManager&quot;: &#123;</div><div class="line">            &quot;methods&quot;: &#123;</div><div class="line">                &quot;query&quot;: &#123;</div><div class="line">                    &quot;type&quot;: &quot;remote&quot;,</div><div class="line">                    &quot;methodID&quot;: 0</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;moduleID&quot;: 4</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">     &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OC端和JS端分别各有一个bridge，两个bridge都保存了同样一份模块配置表，JS调用OC模块方法时，通过bridge里的配置表把模块方法转为模块ID和方法ID传给OC，OC通过bridge的模块配置表找到对应的方法执行之，以上述代码为例，流程大概是这样（先不考虑callback）：<br><img src="http://img.blog.csdn.net/20170114112512625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在了解这个调用流程之前，我们先来看看OC的模块配置表式怎么来的。我们在新建一个OC模块时，JS和OC都不需要为新的模块手动去某个地方添加一些配置，模块配置表是自动生成的，只要项目里有一个模块，就会把这个模块加到配置表上，那这个模块配置表是怎样自动生成的呢？分两个步骤。</p>
<h2 id="1，取所有模块类"><a href="#1，取所有模块类" class="headerlink" title="1，取所有模块类"></a>1，取所有模块类</h2><p>每个模块类都实现了RCTBridgeModule接口，可以通过runtime接口objc_getClassList或objc_copyClassList取出项目里所有类，然后逐个判断是否实现了RCTBridgeModule接口，就可以找到所有模块类，实现在RCTBridgeModuleClassesByModuleID()方法里。</p>
<h2 id="2，取模块里暴露给JS的方法"><a href="#2，取模块里暴露给JS的方法" class="headerlink" title="2，取模块里暴露给JS的方法"></a>2，取模块里暴露给JS的方法</h2><p>一个模块里可以有很多方法，一些是可以暴露给JS直接调用的，一些是私有的不想暴露给JS，怎样做到提取这些暴露的方法呢？我能想到的方法是对要暴露的方法名制定一些规则，比如用RCTExport_作为前缀，然后用runtime方法class<em>getInstanceMethod取出所有方法名字，提取以RCTExport</em>为前缀的方法，但这样做恶心的地方是每个方法必须加前缀。React Native用了另一种黑魔法似的方法解决这个问题：编译属性<strong>attribute</strong>。<br>在上述例子中我们看到模块方法里有句代码：RCT_EXPORT()，模块里的方法加上这个宏就可以实现暴露给JS，无需其他规则，那这个宏做了什么呢？来看看它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define RCT_EXPORT(JS_name) __attribute__((used, section(&quot;__DATA,RCTExport&quot; \</div><div class="line">))) static const char *__rct_export_entry__[] = &#123; __func__, #JS_name &#125;</div></pre></td></tr></table></figure>
<p>这个宏的作用是用编译属性<strong>attribute</strong>给二进制文件新建一个section，属于<strong>DATA数据段，名字为RCTExport，并在这个段里加入当前方法名。编译器在编译时会找到</strong>attribute__进行处理，为生成的可执行文件加入相应的内容。效果可以从linkmap看出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># Sections:</div><div class="line"># Address Size Segment Section</div><div class="line">0x100001670 0x000C0180 __TEXT __text</div><div class="line">...</div><div class="line">0x10011EFA0 0x00000330 __DATA RCTExport</div><div class="line">0x10011F2D0 0x00000010 __DATA __common</div><div class="line">0x10011F2E0 0x000003B8 __DATA __bss</div><div class="line">...</div><div class="line"> </div><div class="line">0x10011EFA0 0x00000010 [ 4] -[RCTStatusBarManager setStyle:animated:].__rct_export_entry__</div><div class="line">0x10011EFB0 0x00000010 [ 4] -[RCTStatusBarManager setHidden:withAnimation:].__rct_export_entry__</div><div class="line">0x10011EFC0 0x00000010 [ 5] -[RCTSourceCode getScriptText:failureCallback:].__rct_export_entry__</div><div class="line">0x10011EFD0 0x00000010 [ 7] -[RCTAlertManager alertWithArgs:callback:].__rct_export_entry__</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到可执行文件数据段多了个RCTExport段，内容就是各个要暴露给JS的方法。这些内容是可以在运行时获取到的，在RCTBridge.m的RCTExportedMethodsByModuleID()方法里获取这些内容，提取每个方法的类名和方法名，就完成了提取模块里暴露给JS方法的工作。整体的模块类/方法提取实现在RCTRemoteModulesConfig()方法里。</p>
<h2 id="js和oc的调用流程分析"><a href="#js和oc的调用流程分析" class="headerlink" title="js和oc的调用流程分析"></a>js和oc的调用流程分析</h2><p>接下来看看JS调用OC模块方法的详细流程，包括callback回调。<br><img src="http://img.blog.csdn.net/20170114112742315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从发起调用到执行回调总共有11个步骤：</p>
<ol>
<li>JS端调用某个OC模块暴露出来的方法。</li>
<li>把上一步的调用分解为ModuleName,MethodName,arguments，再扔给MessageQueue处理。<br>在初始化时模块配置表上的每一个模块都生成了对应的remoteModule对象，对象里也生成了跟模块配置表里一一对应的方法，这些方法里可以拿到自身的模块名，方法名，并对callback进行一些处理，再移交给MessageQueue。具体实现在BatchedBridgeFactory.js的_createBridgedModule里。</li>
<li>在这一步把JS的callback函数缓存在MessageQueue的一个成员变量里，用CallbackID代表callback。在通过保存在MessageQueue的模块配置表把上一步传进来的ModuleName和MethodName转为ModuleID和MethodID。</li>
<li>上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC。</li>
<li>OC接收到消息，通过模块配置表拿到对应的模块和方法。实际上模块配置表已经经过处理了，跟JS一样，在初始化时OC也对模块配置表上的每一个模块生成了对应的实例并缓存起来，模块上的每一个方法也都生成了对应的RCTModuleMethod对象，这里通过ModuleID和MethodID取到对应的Module实例和RCTModuleMethod实例进行调用。具体实现在_handleRequestNumber:moduleID:methodID:params:。</li>
<li>RCTModuleMethod对JS传过来的每一个参数进行处理。RCTModuleMethod可以拿到OC要调用的目标方法的每个参数类型，处理JS类型到目标类型的转换，所有JS传过来的数字都是NSNumber，这里会转成对应的int/long/double等类型，更重要的是会为block类型参数的生成一个block。</li>
<li>OC模块方法调用完，执行block回调。</li>
<li>调用到第6步说明的RCTModuleMethod生成的block。</li>
<li>block里带着CallbackID和block传过来的参数去调JS里MessageQueue的方法invokeCallbackAndReturnFlushedQueue。</li>
<li>MessageQueue通过CallbackID找到相应的JS callback方法。</li>
<li>调用callback方法，并把OC带过来的参数一起传过去，完成回调。<br>概况一下完整的流程如下：JS函数调用转ModuleID/MethodID -&gt; callback转CallbackID -&gt; OC根据ID拿到方法 -&gt; 处理参数 -&gt; 调用OC方法 -&gt; 回调CallbackID -&gt; JS通过CallbackID拿到callback执行。<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2>上述第4步留下一个问题，JS是怎样把数据传给OC，让OC去调相应方法的？<br>答案是通过返回值。JS不会主动传递数据给OC，在调OC方法时，会在上述第4步把ModuleID,MethodID等数据加到一个队列里，等OC过来调JS的任意方法时，再把这个队列返回给OC，此时OC再执行这个队列里要调用的方法。</li>
</ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;React Native用iOS自带的JavaScriptCore作为JS的解析引擎，但并没有用到JavaScriptCore提供的一些可以
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="eact Native" scheme="http://www.xiangzhihong.com/tags/eact-Native/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础语法</title>
    <link href="http://www.xiangzhihong.com/2016/11/05/Swift/"/>
    <id>http://www.xiangzhihong.com/2016/11/05/Swift/</id>
    <published>2016-11-04T16:00:00.000Z</published>
    <updated>2017-07-10T01:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文来自Swift中文开发组，感谢翻译者的分享。<br>本文将分几部分对Swift对iOS的语法做讲解。本文为第一节，主要讲解基础语法。<br>常量和变量</p>
<p>常量和变量把一个名字（比如maximumNumberOfLoginAttempts或者welcomeMessage）和一个指定类型的值（比如数字10或者字符串”Hello”）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。<br>声明常量和变量</p>
<p>常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：<br>[html] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let maximumNumberOfLoginAttempts = 10<br>var currentLoginAttempt = 0<br>这两行代码可以被理解为：“声明一个名字是maximumNumberOfLoginAttempts的新常量，并给它一个值10。然后，声明一个名字是currentLoginAttempt的变量并将它的值初始化为0.”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：<br>[html] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var x = 0.0, y = 0.0, z = 0.0<br>注意：如果你的代码中有不需要改变的值，请使用let关键字将它声明为常量。只将需要改变的值声明为变量。<br>类型标注</p>
<p>当你声明常量或者变量的时候可以加上类型标注(type annotation)，说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给welcomeMessage变量添加了类型标注，表示这个变量可以存储String类型的值：<br>[html] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var welcomeMessage: String<br>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：“声明一个类型为String，名字为welcomeMessage的变量。”</p>
<p>“类型为String”的意思是“可以存储任意String类型的值。”</p>
<p>welcomeMessage变量现在可以被设置成任意字符串：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>welcomeMessage = “Hello”<br>注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给welcomeMessage赋初始值，所以变量welcomeMessage的类型是通过一个类型标注指定的，而不是通过初始值推断的。<br>常量和变量的命名</p>
<p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let π = 3.14159<br>let 你好 = “你好世界”<br>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。<br>注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。<br>你可以更改现有的变量值为其他同类型的值，在下面的例子中，friendlyWelcome的值从”Hello!”改为了”Bonjour!”:<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var friendlyWelcome = “Hello!”<br>friendlyWelcome = “Bonjour!”<br>// friendlyWelcome 现在是 “Bonjour!”<br>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let languageName = “Swift”<br>languageName = “Swift++”<br>// 这会报编译时错误 - languageName 不可改变<br>输出常量和变量</p>
<p>你可以用println函数来输出当前常量或变量的值:<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(friendlyWelcome) // 输出 “Bonjour!”<br>println是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，println将会输出内容到“console”面板上。(另一种函数叫print，唯一区别是在输出内容最后不会换行。)</p>
<p>println函数输出传入的String值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“This is a string”) // 输出 “This is a string”<br>与 Cocoa 里的NSLog函数类似的是，println函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。</p>
<p>Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“The current value of friendlyWelcome is (friendlyWelcome)”)<br>// 输出 “The current value of friendlyWelcome is Bonjour!<br>注意：字符串插值所有可用的选项，请参考字符串插值。</p>
<p>注释</p>
<p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与C 语言的注释非常相似。单行注释以双正斜杠作(//)为起始标记；<br>// 这是一个注释<br>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号(/<em>)，终止标记为一个星号后跟随单个正斜杠(</em>/)<br>/<em> 这是一个, 多行注释 </em>/<br>与C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：<br>/<em> 这是第一个多行注释的开头<br>/</em> 这是第二个被嵌套的多行注释 <em>/<br>这是第一个多行注释的结尾 </em>/<br>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<p>分号</p>
<p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let cat = “<br>整数</p>
<p>整数就是没有小数部分的数字，比如42和-23。整数可以是有符号（正、负、零）或者无符号（正、零）。</p>
<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是UInt8，32位有符号整数类型是Int32。就像 Swift 的其他类型一样，整数类型采用大写命名法。<br>整数范围</p>
<p>你可以访问不同整数类型的min和max属性来获取对应类型的最大值和最小值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let minValue = UInt8.min // minValue 为 0，是 UInt8 类型的最小值<br>let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型的最大值<br>Int</p>
<p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：<br>在32位平台上，Int和Int32长度相同。<br>在64位平台上，Int和Int64长度相同。</p>
<p>除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int可以存储的整数范围也可以达到-2147483648~2147483647，大多数时候这已经足够大了。<br>UInt</p>
<p>Swift 也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同：<br>在32位平台上，UInt和UInt32长度相同。<br>在64位平台上，UInt和UInt64长度相同。<br>注意：尽量不要使用UInt，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用Int，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推测，请参考类型安全和类型推测。<br>浮点数</p>
<p>浮点数是有小数部分的数字，比如3.14159，0.1和-273.15。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比Int类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：<br>Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。<br>Float表示32位浮点数。精度要求不高的话可以使用此类型。<br>注意：Double精确度很高，至少有15位数字，而Float最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。<br>类型安全和类型推测</p>
<p>Swift 是一个类型安全(type safe )的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查(type checks)，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推测(type inference)来选择合适的类型。有了类型推测，编译器可以在编译代码的时候自动推测出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推测，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推测非常有用。当你在声明常量或者变量的时候赋给它们一个字面量(literal value 或 literal)即可触发类型推测。（字面量就是会直接出现在你代码中的值，比如42和3.14159。）</p>
<p>例如，如果你给一个新常量赋值42并且没有标明类型，Swift 可以推测出常量类型是Int，因为你给它赋的初始值看起来像一个整数：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型<br>同理，如果你没有给浮点字面量标明类型，Swift 会推测你想要的是Double：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let pi = 3.14159 // pi 会被推测为 Double 类型<br>当推测浮点数的类型时，Swift 总是会选择Double而不是Float。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推测为Double类型：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let anotherPi = 3 + 0.14159 // anotherPi 会被推测为 Double 类型<br>原始值3没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推测为Double类型。<br>数值型字面量</p>
<p>整数字面量可以被写作：<br>一个十进制数，没有前缀<br>一个二进制数，前缀是0b<br>一个八进制数，前缀是0o<br>一个十六进制数，前缀是0x</p>
<p>下面的所有整数字面量的十进制值都是17:<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let decimalInteger = 17<br>let binaryInteger = 0b10001 // 二进制的17<br>let octalInteger = 0o21 // 八进制的17<br>let hexadecimalInteger = 0x11 // 十六进制的17<br>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是0x）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的指数(exponent)，在十进制浮点数中通过大写或者小写的e来指定，在十六进制浮点数中通过大写或者小写的p来指定。</p>
<p>如果一个十进制数的指数为exp，那这个数相当于基数和$10^{exp}$的乘积：<br>1.25e2 表示 $1.25 × 10^{2}$，等于 125.0。<br>1.25e-2 表示 $1.25 × 10^{-2}$，等于 0.0125。</p>
<p>如果一个十六进制数的指数为exp，那这个数相当于基数和$2^{exp}$的乘积：<br>0xFp2 表示 $15 × 2^{2}$，等于 60.0。<br>0xFp-2 表示 $15 × 2^{-2}$，等于 3.75。</p>
<p>下面的这些浮点字面量都等于十进制的12.1875：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let decimalDouble = 12.1875<br>let exponentDouble = 1.21875e1<br>let hexadecimalDouble = 0xC.3p0<br>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let paddedDouble = 000123.456<br>let oneMillion = 1_000_000<br>let justOverOneMillion = 1_000_000.000_000_1<br>数值型类型转换</p>
<p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用Int类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推测。 只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。<br>整数转换</p>
<p>不同整数类型的变量和常量可以存储不同范围的数字。Int8类型的常量或者变量可以存储的数字范围是-128~127，而UInt8类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let cannotBeNegative: UInt8 = -1 // UInt8 类型不能存储负数，所以会报错<br>let tooBig: Int8 = Int8.max + 1 // Int8 类型不能存储超过最大值的数，所以会报错<br>由于每中整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量twoThousand是UInt16类型，然而常量one是Uint8类型。它们不能直接相加，因为它们类型不同。所以要调用UInt16(one)来创建一个新的UInt16数字并用one的值来初始化，然后使用这个新数字来计算：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let twoThousand: UInt16 = 2_000<br>let one: UInt8 = 1<br>let twoThousandAndOne = twoThousand + UInt16(one)<br>现在两个数字的类型都是UInt16，可以进行相加。目标常量twoThousandAndOne的类型被推测为UInt16，因为它是两个UInt16值的和。</p>
<p>SomeType(ofInitialValue)是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，UInt16有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的UInt8来创建一个新的UInt16。注意，你并不能传入任意类型的值，只能传入UInt16内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考扩展。<br>整数和浮点数转换</p>
<p>整数和浮点数的转换必须显式指定类型：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let three = 3<br>let pointOneFourOneFiveNine = 0.14159<br>let pi = Double(three) + pointOneFourOneFiveNine<br>// pi 等于 3.14159，所以被推测为 Double 类型<br>这个例子中，常量three的值被用来创建一个Double类型的值，所以加号两边的数类型相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用Double或者Float类型来初始化：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let integerPi = Int(pi) // integerPi 等于 3，所以被推测为 Int 类型<br>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说4.75会变成4，-3.9会变成-3。<br>注意：结合数字类常量和变量不同于结合数字类字面量。字面量3可以直接和字面量0.14159相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。<br>类型别名</p>
<p>类型别名(type aliases)就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>typealias AudioSample = UInt16<br>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0<br>本例中，AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0。<br>布尔值</p>
<p>Swift 有一个基本的布尔(Boolean)类型，叫做Bool。布尔值指逻辑上的(logical)，因为它们只能是真或者假。Swift 有两个布尔常量，true和false：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let orangesAreOrange = true<br>let turnipsAreDelicious = false<br>orangesAreOrange和turnipsAreDelicious的类型会被推测为Bool，因为它们的初值是布尔字面量。就像之前提到的Int和Double一样，如果你创建变量的时候给它们赋值true或者false，那你不需要将常量或者变量声明为Bool类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推测，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如if语句的时候，布尔值非常有用：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if turnipsAreDelicious {<br>    println(“Mmm, tasty turnips!”)<br>} else {<br>    println(“Eww, turnips are horrible.”)<br>}<br>// 输出 “Eww, turnips are horrible.”<br>条件语句，例如if，请参考控制流。</p>
<p>如果你在需要使用Bool类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let i = 1 if i { // 这个例子不会通过编译，会报错 }<br>然而，下面的例子是合法的：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let i = 1 if i == 1 { // 这个例子会编译成功 }<br>i == 1的比较结果是Bool类型，所以第二个例子可以通过类型检查。类似i == 1这样的比较，请参考基本操作符。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。<br>元组</p>
<p>元组（tuples）把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，(404, “Not Found”)是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个404 Not Found状态码。<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let http404Error = (404, “Not Found”) // http404Error 的类型是 (Int, String)，值是 (404, “Not Found”)<br>(404, “Not Found”)元组把一个Int值和一个String值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为(Int, String)的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为(Int, Int, Int)或者(String, Bool)或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let (statusCode, statusMessage) = http404Error<br>println(“The status code is (statusCode)”)<br>// 输出 “The status code is 404”<br>println(“The status message is (statusMessage)”)<br>// 输出 “The status message is Not Found”<br>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<em>）标记：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let (justTheStatusCode, </em>) = http404Error<br>println(“The status code is (justTheStatusCode)”)<br>// 输出 “The status code is 404”<br>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“The status code is (http404Error.0)”) // 输出 “The status code is 404”<br>println(“The status message is (http404Error.1)”) // 输出 “The status message is Not Found”<br>你可以在定义元组的时候给单个元素命名：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let http200Status = (statusCode: 200, description: “OK”)<br>给元组中的元素命名后，你可以通过名字来获取这些元素的值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“The status code is (http200Status.statusCode)”) // 输出 “The status code is 200”<br>println(“The status message is (http200Status.description)”) // 输出 “The status message is OK”<br>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个(Int, String)元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考[函数参数与返回值(06_Functions.html#Function_Parameters_and_Return_Values)。<br>注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考类和结构体。<br>可选</p>
<p>使用可选（optionals）来处理值可能缺失的情况。可选表示：<br>有值，等于 x<br>或者<br>没有值<br>注意：C 和 Objective-C 中并没有可选这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选可以让你暗示任意类型的值缺失，并不需要一个特殊值。<br>来看一个例子。Swift 的String类型有一个叫做toInt的方法，作用是将一个String值转换成一个Int值。然而，并不是所有的字符串都可以转换成一个整数。字符串”123”可以被转换成数字123，但是字符串”hello, world”不行。</p>
<p>下面的例子使用toInt方法来尝试将一个String转换成Int：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let possibleNumber = “123”<br>let convertedNumber = possibleNumber.toInt()<br>// convertedNumber 被推测为类型 “Int?”， 或者类型 “optional Int”<br>因为toInt方法可能会失败，所以它返回一个可选的（optional）Int，而不是一个Int。一个可选的Int被写作Int?而不是Int。问号暗示包含的值是可选，也就是说可能包含Int值也可能不包含值。（不能包含其他任何值比如Bool值或者String值。只能是Int或者什么都没有。）<br>if 语句以及强制解析</p>
<p>你可以使用if语句来判断一个可选是否包含值。如果可选有值，结果是true；如果没有值，结果是false。</p>
<p>当你确定可选包确实含值之后，你可以在可选的名字后面加一个感叹号(!)来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if convertedNumber {<br>    println(“(possibleNumber) has an integer value of (convertedNumber!)”)<br>} else {<br>    println(“(possibleNumber) could not be converted to an integer”)<br>}<br>// 输出 “123 has an integer value of 123”<br>更多关于if语句的内容，请参考控制流。<br>注意：使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。<br>可选绑定</p>
<p>使用可选绑定（optional binding）来判断可选是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在if和while语句中来对可选的值进行判断并把值赋给一个常量或者变量。if和while语句，请参考控制流。</p>
<p>像下面这样在if语句中写一个可选绑定：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if let constantName = someOptional { statements }<br>你可以像上面这样使用可选绑定来重写possibleNumber这个例子：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if let actualNumber = possibleNumber.toInt() {<br>    println(“(possibleNumber) has an integer value of (actualNumber)”)<br>} else {<br>    println(“(possibleNumber) could not be converted to an integer”)<br>}<br>// 输出 “123 has an integer value of 123”<br>这段代码可以被理解为：“如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选包含的值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作actualNumber的值，你可以改成if var actualNumber，这样可选包含的值就会被赋给一个变量而非常量。<br>nil</p>
<p>你可以给可选变量赋值为nil来表示它没有值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var serverResponseCode: Int? = 404  // serverResponseCode 包含一个可选的 Int 值 404<br>serverResponseCode = nil // serverResponseCode 现在不包含值<br>注意：nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。<br>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为nil：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var surveyAnswer: String? // surveyAnswer 被自动设置为 nil</p>
<p>注意：Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，nil是一个指向不存在对象的指针。在 Swift 中，nil不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选都可以被设置为nil，不只是对象类型。<br>隐式解析可选</p>
<p>如上所述，可选暗示了常量或者变量可以“没有值”。可选可以通过if语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选被定义为隐式解析可选（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选。</p>
<p>当可选被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选非常有用。隐式解析可选主要被用在 Swift 中类的构造过程中，请参考类实例之间的循环强引用。</p>
<p>一个隐式解析可选其实就是一个普通的可选，但是可以被当做非可选来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选String和隐式解析可选String之间的区别：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let possibleString: String? = “An optional string.”<br>println(possibleString!) // 需要惊叹号来获取值<br>// 输出 “An optional string.”<br>let assumedString: String! = “An implicitly unwrapped optional string.”<br>println(assumedString) // 不需要感叹号<br>// 输出 “An implicitly unwrapped optional string.”<br>你可以把隐式解析可选当做一个可以自动解析的可选。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。<br>注意：如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。<br>你仍然可以把隐式解析可选当做普通可选来判断它是否包含值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if assumedString {<br>    println(assumedString)<br>}<br>// 输出 “An implicitly unwrapped optional string.”<br>你也可以在可选绑定中使用隐式解析可选来检查并解析它的值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if let definiteString = assumedString {<br>    println(definiteString)<br>}<br>// 输出 “An implicitly unwrapped optional string.”<br>注意：如果一个变量之后可能变成nil的话请不要使用隐式解析可选。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来自Swift中文开发组，感谢翻译者的分享。&lt;br&gt;本文将分几部分对Swift对iOS的语法做讲解。本文为第一节，主要讲解基础语法。&lt;br&gt;常量和变量&lt;/p&gt;
&lt;p&gt;常量和变量把一个名字（比如maximumNumberOfLoginAttempts或者welcomeMe
    
    </summary>
    
      <category term="ios" scheme="http://www.xiangzhihong.com/categories/ios/"/>
    
    
      <category term="ios" scheme="http://www.xiangzhihong.com/tags/ios/"/>
    
      <category term="swift" scheme="http://www.xiangzhihong.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>深入理解React Native页面构建渲染原理</title>
    <link href="http://www.xiangzhihong.com/2016/10/28/React%20%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <id>http://www.xiangzhihong.com/2016/10/28/React 页面渲染原理/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2017-07-10T01:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>React Native 是最近非常火的一个话题，因为它的语法简介，跨平台等特性，赢得了各大平台的青睐，虽然前期是有一些坑。</p>
<h2 id="基本概念解释"><a href="#基本概念解释" class="headerlink" title="基本概念解释"></a>基本概念解释</h2><p>React 是一套可以用简洁的语法高效绘制 DOM 的框架，所谓的“高效”，是因为 React 独创了 Virtual DOM 机制。Virtual DOM 是一个存在于内存中的 JavaScript 对象，它与 DOM 是一一对应的关系，也就是说只要有 Virtual DOM，我们就能渲染出 DOM。当界面发生变化时，得益于高效的 DOM Diff 算法，我们能够知道 Virtual DOM 的变化，从而高效的改动 DOM，避免了重新绘制 DOM。</p>
<p>我们知道React是一个专注于 UI 部分框架，对应到 MVC 结构中就是 View 层。要想实现完整的 MVC 架构，还需要 Model 和 Controller 的结构。在前端开发时，我们可以采用 Flux 和 Redux 架构，它们并非框架(Library)，而是和 MVC 一样都是一种架构设计(Architecture)。</p>
<p> 我们知道React Native之所以能再Android/ios等移动设备上运行起来，是因为react native和原生设备之间有一种交互，以ios为例，JavaScript 的形式告诉 Objective-C需要执行什么，然后ios自己去调用 UIKit 等框架绘制界面。所以，React Native 能够运行起来，全靠 Objective-C 和 JavaScript 的交互。</p>
<p>我们知道 C 系列的语言，经过编译，链接等操作后，会得到一个二进制格式的可执行文，所谓的运行程序，其实是运行这个二进制程序。而 JavaScript 是一种脚本语言，它不会经过编译、链接等操作，而是在运行时才动态的进行词法、语法分析，生成抽象语法树(AST)和字节码，然后由解释器负责执行或者使用 JIT 将字节码转化为机器码再执行。整个流程由 JavaScript 引擎负责完成。</p>
<p>苹果提供了一个叫做 JavaScript Core 的框架，这是一个 JavaScript 引擎。通过下面这段代码可以简单的感受一下 Objective-C 如何调用 JavaScript 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];  </div><div class="line">JSValue *jsVal = [context evaluateScript:@&quot;21+7&quot;];  </div><div class="line">int iVal = [jsVal toInt32];</div></pre></td></tr></table></figure>
<p>JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用。很多介绍 React Native 的文章都会提到 “JavaScript 线程” 的概念，实际上，它表示的是 Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。<br>要完全理解JavaScript和Objective-C之前的交互，可以看我之前关于这方面吗的介绍<a href="http://blog.csdn.net/xiangzhihong8/article/details/53366501" target="_blank" rel="external">React native和原生之间的通信</a></p>
<h1 id="React-Native源码剖析"><a href="#React-Native源码剖析" class="headerlink" title="React Native源码剖析"></a>React Native源码剖析</h1><p>在解释React Native的也没渲染原理之前，我们先看几个概念。</p>
<h2 id="ReactElement和ReactClass"><a href="#ReactElement和ReactClass" class="headerlink" title="ReactElement和ReactClass"></a>ReactElement和ReactClass</h2><p><strong>ReactElement</strong><br>一个描述DOM节点或component实例的字面级对象。它包含一些信息，包括组件类型 type 和属性 props 。就像一个描述DOM节点的元素（虚拟节点）。它们可以被创建通过 React.createElement 方法或 jsx 写法。<br>ReactElement分为 DOM Element 和 Component Elements 两类：<br>DOM Elements实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type: &apos;button&apos;,</div><div class="line">  props: &#123;</div><div class="line">    className: &apos;button button-blue&apos;,</div><div class="line">    children: &#123;</div><div class="line">      type: &apos;b&apos;,</div><div class="line">      props: &#123;</div><div class="line">        children: &apos;OK!&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Component Elements</strong><br>当节点的type属性为一个函数或一个类时，它代表自定义的节点。<br>Component Elements实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Button extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; children, color &#125; = this.props;</div><div class="line">    return &#123;</div><div class="line">      type: &apos;button&apos;,</div><div class="line">      props: &#123;</div><div class="line">        className: &apos;button button-&apos; + color,</div><div class="line">        children: &#123;</div><div class="line">          type: &apos;b&apos;,</div><div class="line">          props: &#123;</div><div class="line">            children: children</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Component Elements</div><div class="line">&#123;</div><div class="line">  type: Button,</div><div class="line">  props: &#123;</div><div class="line">    color: &apos;blue&apos;,</div><div class="line">    children: &apos;OK!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ReactClass"><a href="#ReactClass" class="headerlink" title="ReactClass"></a>ReactClass</h2><p>ReactClass是平时我们写的Component组件(类或函数)，例如上面的 Button 类。ReactClass实例化后调用render方法可返回 DOM Element 。<br><img src="http://img.blog.csdn.net/20170114225727446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>如上图所示：</p>
<ol>
<li>调用 React.render 方法，将我们的 element 根虚拟节点渲染到 container 元素中。element 可以是一个字符串文本元素，也可以是如上介绍的 ReactElement 。</li>
<li>根据 element 的类型不同，分别实例化 ReactDOMTextComponent , ReactDOMComponent , ReactCompositeComponent 类。这些类用来管理 ReactElement ,负责将不同的 ReactElement 转化成DOM，并更新DOM。</li>
<li>ReactCompositeComponent 实例调用 mountComponent 方法后内部调用 render 方法，返回了 DOM Elements 。再对如图的步骤:two:递归。<h2 id="React-Native工作原理介绍"><a href="#React-Native工作原理介绍" class="headerlink" title="React Native工作原理介绍"></a>React Native工作原理介绍</h2>要想深入理解 React Native 的工作原理，有两个阶段必须了解：初始化阶段和方法调用阶段。<h3 id="初始化-React-Native"><a href="#初始化-React-Native" class="headerlink" title="初始化 React Native"></a>初始化 React Native</h3>每个项目都有一个入口，然后进行初始化操作，React Native 也不例外。一个不含 Objective-C 代码的项目留给我们的唯一线索就是位于 AppDelegate 文件中，用户能看到的一切内容都来源于这个 RootView ，所有的初始化工作也都在这个方法内完成。</li>
</ol>
<p>在这个方法内部，在创建 RootView 之前，React Native 实际上先创建了一个 Bridge 对象。它是 Objective-C 与 JavaScript 交互的桥梁，后续的方法交互完全依赖于它，而整个初始化过程的最终目的其实也就是创建这个桥梁对象。<br>初始化方法的核心是 setUp 方法，而 setUp 方法的主要任务则是创建 BatchedBridge 。BatchedBridge 的作用是批量读取 JavaScript 对 Objective-C 的方法调用，同时它内部持有一个 JavaScriptExecutor 。创建 BatchedBridge 的关键是 start 方法，它可以分为五个步骤：</p>
<ul>
<li>读取 JavaScript 源码</li>
<li>初始化模块信息</li>
<li>初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象</li>
<li>生成模块列表并写入 JavaScript 端</li>
<li>执行 JavaScript 源码<h3 id="JavaScript-调用-Objective-C"><a href="#JavaScript-调用-Objective-C" class="headerlink" title="JavaScript 调用 Objective-C"></a>JavaScript 调用 Objective-C</h3>在调用 Objective-C 代码时，如前文所述，JavaScript 会解析出方法的 ModuleId 、 MethodId 和 Arguments 并放入到 MessageQueue 中，等待 Objective-C 主动拿走，或者超时后主动发送给 Objective-C。</li>
</ul>
<p>Objective-C 负责处理调用的方法是 handleBuffer ，它的参数是一个含有四个元素的数组，每个元素也都是一个数组，分别存放了 ModuleId 、 MethodId 、 Params ，第四个元素目测用处不大。<br>函数内部在每一次方调用中调用 _handleRequestNumber:moduleID:methodID:params 方法。，通过查找模块配置表找出要调用的方法，并通过 runtime 动态的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[method invokeWithBridge:self module:moduleData.instance arguments:params];</div></pre></td></tr></table></figure>
<p>processMethodSignature ，它会根据 JavaScript 的 CallbackId 创建一个 Block，并且在调用完函数后执行这个 Block。</p>
<h2 id="React-Native更新机制"><a href="#React-Native更新机制" class="headerlink" title="React Native更新机制"></a>React Native更新机制</h2><p><img src="http://img.blog.csdn.net/20170114231157469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>之前我们说过，React是有个状态机这么一说的，就是不行的去检查当前的状态，是否需要刷新。</p>
<h3 id="调用this-setState"><a href="#调用this-setState" class="headerlink" title="调用this.setState"></a>调用this.setState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReactClass.prototype.setState = function(newState) &#123;</div><div class="line">    this._reactInternalInstance.receiveComponent(null, newState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="调用内部receiveComponent方法"><a href="#调用内部receiveComponent方法" class="headerlink" title="调用内部receiveComponent方法"></a>调用内部receiveComponent方法</h3><p>这里在接受元素的时候主要分三种情况，文本元素，基本元素，自定义元素。<br><strong>自定义元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ReactCompositeComponent.prototype.receiveComponent = function(nextElement, transaction, nextContext) &#123;</div><div class="line">    var prevElement = this._currentElement;</div><div class="line">    var prevContext = this._context;</div><div class="line"></div><div class="line">    this._pendingElement = null;</div><div class="line"></div><div class="line">    this.updateComponent(</div><div class="line">      transaction,</div><div class="line">      prevElement,</div><div class="line">      nextElement,</div><div class="line">      prevContext,</div><div class="line">      nextContext</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>updateComponent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReactCompositeComponent.prototype.updateComponent = function(</div><div class="line">    transaction,</div><div class="line">    prevParentElement,</div><div class="line">    nextParentElement,</div><div class="line">    prevUnmaskedContext,</div><div class="line">    nextUnmaskedContext</div><div class="line">)&#123;</div><div class="line">//省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用内部_performComponentUpdate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">ReactCompositeComponent.prototype._updateRenderedComponentWithNextElement = function() &#123;</div><div class="line">   </div><div class="line">   // 判定两个element需不需要更新</div><div class="line">   if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class="line">     // 如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。</div><div class="line">     ReactReconciler.receiveComponent(</div><div class="line">       prevComponentInstance,</div><div class="line">       nextRenderedElement,</div><div class="line">       transaction,</div><div class="line">       this._processChildContext(context)</div><div class="line">     );</div><div class="line">   &#125; else &#123;</div><div class="line">     // 卸载之前的子节点，安装新的子节点</div><div class="line">     var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class="line">     ReactReconciler.unmountComponent(</div><div class="line">       prevComponentInstance,</div><div class="line">       safely,</div><div class="line">       false /* skipLifecycle */</div><div class="line">     );</div><div class="line"></div><div class="line">     var nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class="line">     this._renderedNodeType = nodeType;</div><div class="line">     var child = this._instantiateReactComponent(</div><div class="line">       nextRenderedElement,</div><div class="line">       nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */</div><div class="line">     );</div><div class="line">     this._renderedComponent = child;</div><div class="line"></div><div class="line">     var nextMarkup = ReactReconciler.mountComponent(</div><div class="line">       child,</div><div class="line">       transaction,</div><div class="line">       this._hostParent,</div><div class="line">       this._hostContainerInfo,</div><div class="line">       this._processChildContext(context),</div><div class="line">       debugID</div><div class="line">     );</div><div class="line">   </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>文本元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ReactDOMTextComponent.prototype.receiveComponent(nextText, transaction) &#123;</div><div class="line">     //跟以前保存的字符串比较</div><div class="line">    if (nextText !== this._currentElement) &#123;</div><div class="line">      this._currentElement = nextText;</div><div class="line">      var nextStringText = &apos;&apos; + nextText;</div><div class="line">      if (nextStringText !== this._stringText) &#123;</div><div class="line">        this._stringText = nextStringText;</div><div class="line">        var commentNodes = this.getHostNode();</div><div class="line">        // 替换文本元素</div><div class="line">        DOMChildrenOperations.replaceDelimitedText(</div><div class="line">          commentNodes[0],</div><div class="line">          commentNodes[1],</div><div class="line">          nextStringText</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>基本元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ReactDOMComponent.prototype.receiveComponent = function(nextElement, transaction, context) &#123;</div><div class="line">    var prevElement = this._currentElement;</div><div class="line">    this._currentElement = nextElement;</div><div class="line">    this.updateComponent(transaction, prevElement, nextElement, context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>updateComponent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ReactDOMComponent.prototype.updateComponent = function(transaction, prevElement, nextElement, context) &#123;</div><div class="line">    // 略.....</div><div class="line">    //需要单独的更新属性</div><div class="line">    this._updateDOMProperties(lastProps, nextProps, transaction, isCustomComponentTag);</div><div class="line">    //再更新子节点</div><div class="line">    this._updateDOMChildren(</div><div class="line">      lastProps,</div><div class="line">      nextProps,</div><div class="line">      transaction,</div><div class="line">      context</div><div class="line">    );</div><div class="line"></div><div class="line">    // ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>this._updateDOMChildren 方法内部调用diff算法。<br><img src="http://img.blog.csdn.net/20170114232522307?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">_updateChildren: function(nextNestedChildrenElements, transaction, context) &#123;</div><div class="line">    var prevChildren = this._renderedChildren;</div><div class="line">    var removedNodes = &#123;&#125;;</div><div class="line">    var mountImages = [];</div><div class="line">    </div><div class="line">    // 获取新的子元素数组</div><div class="line">    var nextChildren = this._reconcilerUpdateChildren(</div><div class="line">      prevChildren,</div><div class="line">      nextNestedChildrenElements,</div><div class="line">      mountImages,</div><div class="line">      removedNodes,</div><div class="line">      transaction,</div><div class="line">      context</div><div class="line">    );</div><div class="line">    </div><div class="line">    if (!nextChildren &amp;&amp; !prevChildren) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var updates = null;</div><div class="line">    var name;</div><div class="line">    var nextIndex = 0;</div><div class="line">    var lastIndex = 0;</div><div class="line">    var nextMountIndex = 0;</div><div class="line">    var lastPlacedNode = null;</div><div class="line"></div><div class="line">    for (name in nextChildren) &#123;</div><div class="line">      if (!nextChildren.hasOwnProperty(name)) &#123;</div><div class="line">        continue;</div><div class="line">      &#125;</div><div class="line">      var prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">      var nextChild = nextChildren[name];</div><div class="line">      if (prevChild === nextChild) &#123;</div><div class="line">          // 同一个引用，说明是使用的同一个component,所以我们需要做移动的操作</div><div class="line">          // 移动已有的子节点</div><div class="line">          // NOTICE：这里根据nextIndex, lastIndex决定是否移动</div><div class="line">        updates = enqueue(</div><div class="line">          updates,</div><div class="line">          this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex)</div><div class="line">        );</div><div class="line">        </div><div class="line">        // 更新lastIndex</div><div class="line">        lastIndex = Math.max(prevChild._mountIndex, lastIndex);</div><div class="line">        // 更新component的.mountIndex属性</div><div class="line">        prevChild._mountIndex = nextIndex;</div><div class="line">        </div><div class="line">      &#125; else &#123;</div><div class="line">        if (prevChild) &#123;</div><div class="line">          // 更新lastIndex</div><div class="line">          lastIndex = Math.max(prevChild._mountIndex, lastIndex);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 添加新的子节点在指定的位置上</div><div class="line">        updates = enqueue(</div><div class="line">          updates,</div><div class="line">          this._mountChildAtIndex(</div><div class="line">            nextChild,</div><div class="line">            mountImages[nextMountIndex],</div><div class="line">            lastPlacedNode,</div><div class="line">            nextIndex,</div><div class="line">            transaction,</div><div class="line">            context</div><div class="line">          )</div><div class="line">        );</div><div class="line">        </div><div class="line">        </div><div class="line">        nextMountIndex++;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      // 更新nextIndex</div><div class="line">      nextIndex++;</div><div class="line">      lastPlacedNode = ReactReconciler.getHostNode(nextChild);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 移除掉不存在的旧子节点，和旧子节点和新子节点不同的旧子节点</div><div class="line">    for (name in removedNodes) &#123;</div><div class="line">      if (removedNodes.hasOwnProperty(name)) &#123;</div><div class="line">        updates = enqueue(</div><div class="line">          updates,</div><div class="line">          this._unmountChild(prevChildren[name], removedNodes[name])</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>react的优点总结：</p>
<ul>
<li>虚拟节点。在UI方面，不需要立刻更新视图，而是生成虚拟DOM后统一渲染。</li>
<li>组件机制。各个组件独立管理,层层嵌套，互不影响，react内部实现的渲染功能。</li>
<li>差异算法。根据基本元素的key值，判断是否递归更新子节点，还是删除旧节点，添加新节点。</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;React Native 是最近非常火的一个话题，因为它的语法简介，跨平台等特性，赢得了各大平台的青睐，虽然前期是有一些坑。&lt;/p&gt;
&lt;h2
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>React Native之StyleSheet样式表</title>
    <link href="http://www.xiangzhihong.com/2016/10/18/StyleSheet%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
    <id>http://www.xiangzhihong.com/2016/10/18/StyleSheet样式表/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2017-07-10T01:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在React Native中，StyleSheet是实现了类似Web中CSS样式表的功能。最简单的使用如下，先定一个StyleSheet的样式表，然后在View中引用样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    borderRadius: 4,</div><div class="line">    borderWidth: 0.5,</div><div class="line">    borderColor: &apos;#d6d7da&apos;,</div><div class="line">  &#125;,</div><div class="line">  title: &#123;</div><div class="line">    fontSize: 19,</div><div class="line">    fontWeight: &apos;bold&apos;,</div><div class="line">  &#125;,</div><div class="line">  activeTitle: &#123;</div><div class="line">    color: &apos;red&apos;,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>view中引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">  &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<h1 id="StyleSheet样式表的优点"><a href="#StyleSheet样式表的优点" class="headerlink" title="StyleSheet样式表的优点"></a>StyleSheet样式表的优点</h1><p>采用StyleSheet样式表的优点注意如下：<br><strong>从代码质量角度来分析:</strong></p>
<ul>
<li>从render渲染方法中移除了styles样式相关代码，这样可以使代码更加容易阅读</li>
<li>通过对不同样式命名，正好也是对render方法中的组件的一种标志</li>
<li>这样的写法做到了业务和样式的分离，为后面分层开发打下了基础</li>
</ul>
<p><strong>从性能角度来分析:</strong></p>
<ul>
<li>通过StyleSheet，我们可以通过标志的样式ID来引用，而不是每次都要创建一个新的Style对象</li>
<li>该允许样式通过桥接在原生代码和JavaScript中传递一次，后面全部通过该id进行引用(不过现在该功能还没有实现)</li>
</ul>
<h1 id="StyleSheet使用"><a href="#StyleSheet使用" class="headerlink" title="StyleSheet使用"></a>StyleSheet使用</h1><h2 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h2><p>create(obj:{[key:string]:any})  static 静态方法   通过给定的对象进行常见一个StyleSheet样式</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li><p>.hairlineWidth:CallExpression<br>该用来定义当前平台最细的宽度。该属性用来设置边框或者两个组件之间的分割线。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    borderBottomColor: &apos;#bbb&apos;,</div><div class="line">    borderBottomWidth: StyleSheet.hairlineWidth</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flatten: CallExpression<br>使用异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var styles = StyleSheet.create(&#123; </div><div class="line">listItem: &#123; </div><div class="line">flex: 1, fontSize: 16, color: &apos;white&apos; &#125;, selectedListItem: &#123; color: &apos;green&apos; &#125; &#125;); </div><div class="line">StyleSheet.flatten([styles.listItem, styles.selectedListItem]) </div><div class="line">// returns &#123; flex: 1, fontSize: 16, color: &apos;green&apos; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在React Native中，StyleSheet是实现了类似Web中CSS样式表的功能。最简单的使用如下，先定一个StyleSheet的样
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="Spring" scheme="http://www.xiangzhihong.com/tags/Spring/"/>
    
      <category term="入门" scheme="http://www.xiangzhihong.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot入门</title>
    <link href="http://www.xiangzhihong.com/2016/10/12/Spring%20Boot%E6%90%AD%E5%BB%BAWeb%E5%BA%94%E7%94%A8/"/>
    <id>http://www.xiangzhihong.com/2016/10/12/Spring Boot搭建Web应用/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2017-07-10T01:30:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h1><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式,Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。<br>用一句话：不用自己做配置，搭建速度快，降低学习门槛。</p>
<p>Spring Boot 在 Spring 生态中的位置：<br><img src="http://img.blog.csdn.net/20170221224730657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Spring-Boot的特点"><a href="#Spring-Boot的特点" class="headerlink" title="Spring Boot的特点"></a>Spring Boot的特点</h2><ul>
<li>为所有Spring开发者更快的入门</li>
<li>不用看那么一坨xml真的很神清气爽</li>
<li>嵌入的Tomcat，无需部署WAR文件</li>
<li>开箱即用，提供各种默认配置来简化项目配置</li>
</ul>
<p>如：快速在 Java 代码中测试和使用 Spring Boot 的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import org.springframework.boot.*;</div><div class="line">import org.springframework.boot.autoconfigure.*;</div><div class="line">import org.springframework.web.bind.annotation.*;</div><div class="line"></div><div class="line">@RestController</div><div class="line">@EnableAutoConfiguration</div><div class="line">public class Example &#123;</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/&quot;)</div><div class="line">    String home() &#123;</div><div class="line">        return &quot;Hello World!&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        SpringApplication.run(Example.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Spring-Boot使用"><a href="#Spring-Boot使用" class="headerlink" title="Spring Boot使用"></a>Spring Boot使用</h2><p>打开网址：<a href="http://start.spring.io/" target="_blank" rel="external">http://start.spring.io/</a>，按照图中填写信息。<br><img src="http://img.blog.csdn.net/20170221225233050?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>点击Generate Project下载项目压缩包，解压项目包，并用IDE以Maven项目导入</p>
<h2 id="导入Web模块："><a href="#导入Web模块：" class="headerlink" title="导入Web模块："></a>导入Web模块：</h2><p>在pom.xml中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>编写Controller类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">publicclassHelenController&#123; </div><div class="line">@RequestMapping(&quot;/hello&quot;) </div><div class="line">publicStringindex()</div><div class="line">&#123;</div><div class="line">return&quot;hello world&quot;;</div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个入门的hello 就搭建好了。打开浏览器：<a href="http://localhost:8080/hello，你会发现输出：hello" target="_blank" rel="external">http://localhost:8080/hello，你会发现输出：hello</a> word<br>接下来我们要说说Thymeleaf模板。</p>
<h1 id="引入Thymeleaf模板引擎开发web项目"><a href="#引入Thymeleaf模板引擎开发web项目" class="headerlink" title="引入Thymeleaf模板引擎开发web项目"></a>引入Thymeleaf模板引擎开发web项目</h1><h2 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h2><p><img src="http://img.blog.csdn.net/20170222215318842?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Controller类及HTML页面"><a href="#Controller类及HTML页面" class="headerlink" title="Controller类及HTML页面"></a>Controller类及HTML页面</h2><p><img src="http://img.blog.csdn.net/20170222215340859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170222215429250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>如上页面，直接打开html页面展现Hello World，但是启动程序后，访问<a href="http://localhost:8080/，则是展示Controller中host的值：从很小就坏，做到了不破坏HTML自身内容的数据逻辑分离。" target="_blank" rel="external">http://localhost:8080/，则是展示Controller中host的值：从很小就坏，做到了不破坏HTML自身内容的数据逻辑分离。</a></p>
<h2 id="Thymeleaf模板"><a href="#Thymeleaf模板" class="headerlink" title="Thymeleaf模板"></a>Thymeleaf模板</h2><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。<br>Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。</p>
<h1 id="Spring-Boot整合Spring-Security权限"><a href="#Spring-Boot整合Spring-Security权限" class="headerlink" title="Spring Boot整合Spring Security权限"></a>Spring Boot整合Spring Security权限</h1><p>整合Spring Security需要在pom.xml添加依赖<br><img src="http://img.blog.csdn.net/20170222215838814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Spring Security配置：<br><img src="http://img.blog.csdn.net/20170222215909881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ol>
<li>通过@EnableWebSecurity注解开启Spring Security的功能</li>
<li>继承WebSecurityConfigurerAdapter，并重写它的方法来设置一些web安全的细节</li>
<li>configure(HttpSecurity<br>http)方法通过authorizeRequests()定义哪些URL需要被保护、哪些不需要被保护。例如以上代码指定了/和/home不需要任何认证就可以访问，其他的路径都必须通过身份验证。</li>
<li>通过formLogin()定义当需要用户登录时候，转到的登录页面。</li>
<li>configureGlobal(AuthenticationManagerBuilder<pre><code>auth)方法，在内存中创建了一个用户，该用户的名称为user，密码为password，用户角色为USER。
</code></pre></li>
</ol>
<p>然后在Controller做拦截操作。<br><img src="http://img.blog.csdn.net/20170222220059820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>结果页面<br><img src="http://img.blog.csdn.net/20170222220127196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>最后启动<a href="http://localhost:8080/就可以啦" target="_blank" rel="external">http://localhost:8080/就可以啦</a></p>
<p>附:<a href="http://www.thymeleaf.org/documentation.html" target="_blank" rel="external">thymeleaf 中文文档</a><br><a href="http://www.cnblogs.com/vinphy/p/4673918.html" target="_blank" rel="external">thymeleaf 基础教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot简介&quot;&gt;&lt;a href=&quot;#Spring-Boot简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot简介&quot;&gt;&lt;/a&gt;Spring Boot简介&lt;/h1&gt;&lt;p&gt;Spring Boot是由Pivotal团队提供的全
    
    </summary>
    
      <category term="Spring" scheme="http://www.xiangzhihong.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.xiangzhihong.com/tags/Spring/"/>
    
      <category term="入门" scheme="http://www.xiangzhihong.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>React Native在Android平台运行gif的解决方法</title>
    <link href="http://www.xiangzhihong.com/2016/10/08/React%20Native%E5%9C%A8Android%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8Cgif%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.xiangzhihong.com/2016/10/08/React Native在Android平台运行gif的解决方法/</id>
    <published>2016-10-07T16:00:00.000Z</published>
    <updated>2017-07-10T01:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目前RN在Android平台上不支持gif格式的图片，而在ios平台是支持的，期待以后的版本中系统也是可以默认支持Android的。首先说下在ios平台怎么加载gif呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image source= &#123;require(&apos;./img/loading.gif&apos;)&#125; style = &#123;styles.loading&#125;/&gt;</div></pre></td></tr></table></figure>
<p>完整实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">xport default class Loading extends React.Component &#123;  </div><div class="line">    render()&#123;  </div><div class="line">  </div><div class="line">        if (!this.props.isShow) &#123;  </div><div class="line">            return &lt;View /&gt;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        return (  </div><div class="line">            &lt;View style = &#123;styles.container&#125;&gt;  </div><div class="line">                &lt;Image source= &#123;require(&apos;./img/loading.gif&apos;)&#125; style = &#123;styles.loading&#125;/&gt;  </div><div class="line">            &lt;/View&gt;  </div><div class="line">        )  </div><div class="line">    &#125;;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">const styles = StyleSheet.create(&#123;  </div><div class="line">  container:&#123;  </div><div class="line">    backgroundColor: &apos;transparent&apos;,  </div><div class="line">    position: &apos;absolute&apos;,  </div><div class="line">    top: 0,  </div><div class="line">    left: 0,  </div><div class="line">    height: Util.screenSizeUtil.height,  </div><div class="line">    width: Util.screenSizeUtil.width,  </div><div class="line">    alignItems: &apos;center&apos;,  </div><div class="line">    justifyContent: &apos;center&apos;,  </div><div class="line">  </div><div class="line">  &#125;,  </div><div class="line">  loading:&#123;  </div><div class="line">    height:30,  </div><div class="line">    width:30,  </div><div class="line">  &#125;,  </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="RN在Android平台的解决方法"><a href="#RN在Android平台的解决方法" class="headerlink" title="RN在Android平台的解决方法"></a>RN在Android平台的解决方法</h1><h2 id="facebook-fresco方法"><a href="#facebook-fresco方法" class="headerlink" title="facebook fresco方法"></a>facebook fresco方法</h2><p>要解决上面的问题，方法还是很多的，最简单的莫过于使用facebook的jar支持库，在android/app/build.gradle文件中新增</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.facebook.fresco:animated-gif:0.13.0&apos;</div></pre></td></tr></table></figure>
<p>Fresco是一个强大的图片加载组件，Android 本身的图片库不支持此格式，但是Fresco支持。使用时，和往常一样，仅仅需要提供一个图片的URI即可，剩下的事情，Fresco会处理。<br>如我们运行一个名为loading.gif的图片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image source=&#123;&#123;uri:loading&#125;&#125; style=&#123;&#123;width:20,height:20&#125;&#125;/&gt;</div></pre></td></tr></table></figure>
<p>当然网上还有另外的方法，就是自己去实现读取gif图片，对图片资源做拆解，这有点类似于，在很久以前，Android平台也是不支持gif的，出现了自定义view对gif图片进行拆解，然后运行image的方案。有点类似于Android的帧动画，在xml定义图片数组，然后使用Animator来加载。不过这种方法性能差。</p>
<h2 id="自定义组件实现"><a href="#自定义组件实现" class="headerlink" title="自定义组件实现"></a>自定义组件实现</h2><p>将gif切成15张png的图片，暂且命名为loading1、loading2…. loading15。</p>
<h3 id="在构造方法中初始化图片数组"><a href="#在构造方法中初始化图片数组" class="headerlink" title="在构造方法中初始化图片数组"></a>在构造方法中初始化图片数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//图片数组  </div><div class="line">var loading_imgs = new Array();  </div><div class="line">//最大图片张数  </div><div class="line">const imageLength = 15;  </div><div class="line">//动画使用的数组下标  </div><div class="line">const imageIndex = 0;  </div><div class="line">  </div><div class="line">  </div><div class="line">  constructor(props) &#123;  </div><div class="line">      super(props);  </div><div class="line">      this.state = &#123;  </div><div class="line">          dataSource: new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2,&#125;),    </div><div class="line">          ….  </div><div class="line">          imageIndex:imageIndex,  </div><div class="line">      &#125;;  </div><div class="line">        </div><div class="line">//组装图片数组   共15张图片  loading1  -&gt; loading15  </div><div class="line">      for( i=1;i&lt;= imageLength;i++)&#123;  </div><div class="line">        let loadingUri = &quot;loading&quot; + i;  </div><div class="line">        let img = &lt;Image source=&#123;&#123;uri:loadingUri&#125;&#125; key=&#123;i&#125; style=&#123;&#123;width:20,height:20&#125;&#125;/&gt;;  </div><div class="line">        loading_imgs.push(img);  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="也没渲染"><a href="#也没渲染" class="headerlink" title="也没渲染"></a>也没渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">render() &#123;  </div><div class="line">  return (  </div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;  </div><div class="line">          &lt;View style=&#123;&#123;position:&apos;absolute&apos;, top:-1000&#125;&#125;&gt;  </div><div class="line">            &#123;  </div><div class="line">              loading_imgs.map((item,i)=&gt; loading_imgs[i])  </div><div class="line">            &#125;  </div><div class="line">          &lt;/View&gt;  </div><div class="line">     &lt;/View&gt;  </div><div class="line">)&#125;;</div></pre></td></tr></table></figure>
<h3 id="轮播图片"><a href="#轮播图片" class="headerlink" title="轮播图片"></a>轮播图片</h3><p>每隔100毫秒切换一张图片，当数据加载完毕，清楚定时任务，并且将图片置为第一张。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">图片轮播函数  </div><div class="line">  _loop() &#123;  </div><div class="line">    this.loopCount++;  </div><div class="line">    if (this.loopCount &lt; loading_imgs.length) &#123;  </div><div class="line">        this.setState(&#123;  </div><div class="line">            imageIndex: this.loopCount,  </div><div class="line">        &#125;);  </div><div class="line">    &#125;else &#123;  </div><div class="line">        this.loopCount = -1;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">//轮播图片  </div><div class="line">this.timerPic = setInterval(this._loop.bind(this), 100);  </div><div class="line">  </div><div class="line">//清除图片轮播效果  </div><div class="line">this.timer1 &amp;&amp; clearInterval(this.timer1);  </div><div class="line">this.loopCount = -1;</div></pre></td></tr></table></figure></p>
<p>这样就实现了自己实现对gif运行的实现，不过其性能确实太差，建议使用第一种。</p>
<p>附：<a href="http://lib.csdn.net/xiangzhihong8/5375/chart/React%20Native" target="_blank" rel="external">RN知识库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;目前RN在Android平台上不支持gif格式的图片，而在ios平台是支持的，期待以后的版本中系统也是可以默认支持Android的。首先说下
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="android" scheme="http://www.xiangzhihong.com/tags/android/"/>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android WindowManager详解</title>
    <link href="http://www.xiangzhihong.com/2016/10/05/Android%20WindowManager%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xiangzhihong.com/2016/10/05/Android WindowManager详解/</id>
    <published>2016-10-04T16:00:00.000Z</published>
    <updated>2017-07-09T12:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>WindowManager是Android中一个重要的服务（Service ）。WindowManager Service 是全局的，是唯一的。它将用户的操作，翻译成为指令，发送给呈现在界面上的各个Window。Activity会将顶级的控件注册到 Window Manager 中，<br>当用户真是触碰屏幕或键盘的时候，Window Manager就会通知到，而当控件有一些请求产生，也会经由ViewParent送回到Window Manager中。从而完成整个通信流程。<br>整个Android的窗口机制是基于一个叫做 WindowManager，这个接口可以添加view到屏幕，也可以从屏幕删除view。它面向的对象一端是屏幕，另一端就是View，通过WindowManager的 addView方法创建View，这样产生出来的View根据<br>WindowManager.LayoutParams属性不同，效果也就不同了。比如创建 系统顶级窗口，实现悬浮窗口效果！WindowManager的方法很简单，基本用到的就三addView，removeView，updateViewLayout。接口，而WindowManager.LayoutParams的属性就多了，后面为大家一一详解。</p>
<h2 id="WindowManager小实例"><a href="#WindowManager小实例" class="headerlink" title="WindowManager小实例"></a>WindowManager小实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Button bb=new Button(getApplicationContext());  </div><div class="line">WindowManager wmManager=(WindowManager) getSystemService(Context.WINDOW_SERVICE);  </div><div class="line">WindowManager.LayoutParams wmParams = new WindowManager.LayoutParams();  </div><div class="line"></div><div class="line">       wmParams.type=2002;   </div><div class="line">       wmParams.format=1;  </div><div class="line">       </div><div class="line">       wmParams.flags=40;  </div><div class="line">       wmParams.width=40;  </div><div class="line">       wmParams.height=40;  </div><div class="line">         </div><div class="line">       wmManager.addView(bb, wmParams);</div></pre></td></tr></table></figure>
<p>解释：创建了一个Button对象然后通过WindowManager实例对象的addView添加这个ButtonVIew并根据相应的LayoutParams参数进行显示。</p>
<h1 id="WindowManager属性详解"><a href="#WindowManager属性详解" class="headerlink" title="WindowManager属性详解"></a>WindowManager属性详解</h1><p><strong>继承关系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">   ↳android.view.ViewGroup.LayoutParams</div><div class="line">       ↳android.view.WindowManager.LayoutParams</div></pre></td></tr></table></figure>
<p><strong>继承来的属性与常量</strong><br>从 ViewManager.LayoutParams 继承来的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android:layout_height</div><div class="line">        Specifies the basic height of the view.</div><div class="line"></div><div class="line">   android:layout_width</div><div class="line">        Specifies the basic width of the view.</div></pre></td></tr></table></figure>
<p>从 ViewManager.LayoutParams继承的常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FILL_PARENT</div><div class="line">    WRAP_CONTENT</div><div class="line">    MATCH_PARENT</div></pre></td></tr></table></figure>
<h2 id="其他可用的常量定义"><a href="#其他可用的常量定义" class="headerlink" title="其他可用的常量定义"></a>其他可用的常量定义</h2><p><strong>public int x;</strong><br>如果忽略gravity属性，那么它表示窗口的绝对X位置。<br>当设置了 Gravity.LEFT 或 Gravity.RIGHT 之后，x值就表示到特定边的距离。</p>
<p><strong>public int y;</strong><br>如果忽略gravity属性，那么它表示窗口的绝对Y位置。<br>当设置了 Gravity.TOP 或 Gravity.BOTTOM 之后，y值就表示到特定边的距离。</p>
<p><strong>public float horizontalWeight/public float verticalWeight;</strong><br>在纵/横向上，为关联的view预留了多少扩展空间（像素）。如果是0，那么此view不能被拉伸。其他情况下，扩展空间（像素）将被widget所均分。</p>
<p><strong>public int type;</strong><br>窗口类型。有3种主要类型：<br> a)Applicationwindows：<br>        取值在 FIRST_APPLICATION_WINDOW 和 LAST_APPLICATION_WINDOW 之间。<br>        是通常的、顶层的应用程序窗口。必须将 token 设置成 activity 的 token 。</p>
<p>b)Sub_windows：<br>        取值在 FIRST_SUB_WINDOW 和 LAST_SUB_WINDOW 之间。<br>        与顶层窗口相关联，token 必须设置为它所附着的宿主窗口的 token。</p>
<p>c)Systemwindows：<br>        取值在 FIRST_SYSTEM_WINDOW 和 LAST_SYSTEM_WINDOW 之间。<br>        用于特定的系统功能。它不能用于应用程序，使用时需要特殊权限。</p>
<p><strong>public int memoryType;</strong><br>   指出窗口所使用的内存缓冲类型。默认为 NORMAL 。</p>
<p>下面定义了 memoryType 的取值：<br>窗口缓冲位于主内存。<br>public static final int MEMORY_TYPE_NORMAL = 0;</p>
<p>窗口缓冲位于可以被DMA访问，或者硬件加速的内存区域。<br>public static final int MEMORY_TYPE_HARDWARE = 1;</p>
<p>窗口缓冲位于可被图形加速器访问的区域。<br>public static final int MEMORY_TYPE_GPU = 2;</p>
<p>窗口缓冲不拥有自己的缓冲区，不能被锁定。缓冲区由本地方法提供。<br>public static final int MEMORY_TYPE_PUSH_BUFFERS = 3;</p>
<p><strong>public int flags</strong><br>行为选项/旗标，默认为 none .<br>下面定义了 flags 的取值：<br>窗口之后的内容变暗。<br>public static final int FLAG_DIM_BEHIND       = 0x00000002;</p>
<p>窗口之后的内容变模糊。<br>public static final int FLAG_BLUR_BEHIND       = 0x00000004;</p>
<p>不许获得焦点。<br>public static final int FLAG_NOT_FOCUSABLE     = 0x00000008;</p>
<p>不接受触摸屏事件。<br>public static final int FLAG_NOT_TOUCHABLE     = 0x00000010;</p>
<p>当窗口可以获得焦点（没有设置 FLAG_NOT_FOCUSALBE 选项）时，仍然将窗口范围之外的点设备事件（鼠标、触摸屏）发送给后面的窗口处理。否则它将独占所有的点设备事件，而不管它们是不是发生在窗口范围内。<br>public static final int FLAG_NOT_TOUCH_MODAL   = 0x00000020;</p>
<p> 如果设置了这个标志，当设备休眠时，点击触摸屏，设备将收到这个第一触摸事件。通常第一触摸事件被系统所消耗，用户不会看到他们点击屏幕有什么反应。<br>public static final int FLAG_TOUCHABLE_WHEN_WAKING = 0x00000040;</p>
<p>当此窗口为用户可见时，保持设备常开，并保持亮度不变。<br>public static final int FLAG_KEEP_SCREEN_ON    = 0x00000080;</p>
<p>窗口占满整个屏幕，忽略周围的装饰边框（例如状态栏）。此窗口需考虑到装饰边框的内容。<br>public static final int FLAG_LAYOUT_IN_SCREEN   =0x00000100;</p>
<p>允许窗口扩展到屏幕之外。<br>public static final int FLAG_LAYOUT_NO_LIMITS   =0x00000200;</p>
<p>窗口显示时，隐藏所有的屏幕装饰（例如状态条）。使窗口占用整个显示区域。<br>public static final int FLAG_FULLSCREEN     = 0x00000400;</p>
<p>此选项将覆盖FLAG_FULLSCREEN选项，并强制屏幕装饰（如状态条）弹出。<br>public static final int FLAG_FORCE_NOT_FULLSCREEN   =0x00000800;</p>
<p>抖动。指 对半透明的显示方法。又称“点透”。图形处理较差的设备往往用“点透”替代Alpha混合。<br>public static final int FLAG_DITHER = 0x00001000;</p>
<p>不允许屏幕截图。<br>public static final int FLAG_SECURE           = 0x00002000;</p>
<p>一种特殊模式，布局参数用于指示显示比例。<br>public static final int FLAG_SCALED           = 0x00004000;</p>
<p>当屏幕有可能贴着脸时，这一选项可防止面颊对屏幕造成误操作。<br>public static final int FLAG_IGNORE_CHEEK_PRESSES   = 0x00008000;</p>
<p>当请求布局时，你的窗口可能出现在状态栏的上面或下面，从而造成遮挡。当设置这一选项后，窗口管理器将确保窗口内容不会被装饰条（状态栏）盖住。<br>public static final int FLAG_LAYOUT_INSET_DECOR = 0x00010000;</p>
<p>反转FLAG_NOT_FOCUSABLE选项。<br>如果同时设置了FLAG_NOT_FOCUSABLE选项和本选项，窗口将能够与输入法交互，允许输入法窗口覆盖；      如果FLAG_NOT_FOCUSABLE没有设置而设置了本选项，窗口不能与输入法交互，可以覆盖输入法窗口。<br>public static final int FLAG_ALT_FOCUSABLE_IM = 0x00020000;</p>
<p>如果你设置了FLAG_NOT_TOUCH_MODAL，那么当触屏事件发生在窗口之外事，可以通过设置此标志接收到一个 MotionEvent.ACTION_OUTSIDE事件。注意，你不会收到完整的down/move/up事件，只有第一次down事件时可以收到 ACTION_OUTSIDE。<br>public static final int FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;</p>
<p>当屏幕锁定时，窗口可以被看到。这使得应用程序窗口优先于锁屏界面。可配合FLAG_KEEP_SCREEN_ON选项点亮屏幕并直接显示在锁屏界面之前。可使用FLAG_DISMISS_KEYGUARD选项直接解除非加锁的锁屏状态。此选项只用于最顶层的全屏幕窗口。      public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;</p>
<p>请求系统墙纸显示在你的窗口后面。窗口必须是半透明的。<br>public static final int FLAG_SHOW_WALLPAPER = 0x00100000;</p>
<p>窗口一旦显示出来，系统将点亮屏幕，正如用户唤醒设备那样。<br>public static final int FLAG_TURN_SCREEN_ON = 0x00200000;</p>
<p>解除锁屏。只有锁屏界面不是加密的才能解锁。如果锁屏界面是加密的，那么用户解锁之后才能看到此窗口，除非设置了FLAG_SHOW_WHEN_LOCKED选项。<br>public static final int FLAG_DISMISS_KEYGUARD = 0x00400000;</p>
<p>锁屏界面淡出时，继续运行它的动画。<br>public static final int FLAG_KEEP_SURFACE_WHILE_ANIMATING =0x10000000;</p>
<p>以原始尺寸显示窗口。用于在兼容模式下运行程序。<br>public static final int FLAG_COMPATIBLE_WINDOW = 0x20000000;</p>
<p>用于系统对话框。设置此选项的窗口将无条件获得焦点。<br>public static final int FLAG_SYSTEM_ERROR = 0x40000000;</p>
<p><strong>public int softInputMode</strong>（重要）<br>以下选项与 softInputMode 有关：<br>软输入区域是否可见。<br>public static final int SOFT_INPUT_MASK_STATE = 0x0f;</p>
<p>未指定状态。<br>public static final int SOFT_INPUT_STATE_UNSPECIFIED = 0;</p>
<p>不要修改软输入法区域的状态。<br>public static final int SOFT_INPUT_STATE_UNCHANGED = 1;</p>
<p>隐藏输入法区域（当用户进入窗口时）。<br>public static final int SOFT_INPUT_STATE_HIDDEN = 2;</p>
<p>当窗口获得焦点时，隐藏输入法区域。<br>public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;</p>
<p>显示输入法区域（当用户进入窗口时）。<br>public static final int SOFT_INPUT_STATE_VISIBLE = 4;</p>
<p>当窗口获得焦点时，显示输入法区域。<br> public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;</p>
<p>窗口应当主动调整，以适应软输入窗口。<br>public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;</p>
<p>未指定状态，系统将根据窗口内容尝试选择一个输入法样式。<br>public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;</p>
<p>当输入法显示时，允许窗口重新计算尺寸，使内容不被输入法所覆盖。不可与SOFT_INPUT_ADJUSP_PAN混合使用,如果两个都没有设置，系统将根据窗口内容自动设置一个选项。<br> public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;</p>
<p>输入法显示时平移窗口。它不需要处理尺寸变化，框架能够移动窗口以确保输入焦点可见。不可与SOFT_INPUT_ADJUST_RESIZE混合使用;如果两个都没设置,系统将根据窗口内容自动设置一个选项。<br> public static final int SOFT_INPUT_ADJUST_PAN = 0x20;</p>
<p>当用户转至此窗口时，由系统自动设置，所以你不要设置它。当窗口显示之后该标志自动清除。<br> public static final int SOFT_INPUT_IS_FORWARD_NAVIGATION = 0x100;</p>
<p><strong>public float horizontalMargin/public float verticalMargin</strong><br>水平边距/ 纵向边距，容器与widget之间的距离，占容器宽度的百分率。</p>
<p><strong>public int windowAnimations</strong><br> 窗口所使用的动画设置。它必须是一个系统资源而不是应用程序资源，因为窗口管理器不能访问应用程序。</p>
<p><strong>public float alpha</strong><br>整个窗口的透明值。</p>
<h2 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h2><p>public staticfinal int LAYOUT_CHANGED =1&lt;&lt;0;<br>    public staticfinal int TYPE_CHANGED =1&lt;&lt;1;<br>    public staticfinal int FLAGS_CHANGED =1&lt;&lt;2;<br>    public staticfinal int FORMAT_CHANGED =1&lt;&lt;3;<br>    public staticfinal int ANIMATION_CHANGED =1&lt;&lt;4;<br>    public staticfinal int DIM_AMOUNT_CHANGED =1&lt;&lt;5;<br>    public staticfinal int TITLE_CHANGED =1&lt;&lt;6;<br>    public staticfinal int ALPHA_CHANGED =1&lt;&lt;7;<br>    public staticfinal int MEMORY_TYPE_CHANGED =1&lt;&lt;8;<br>    public staticfinal int SOFT_INPUT_MODE_CHANGED =1&lt;&lt;9;<br>    public staticfinal int SCREEN_ORIENTATION_CHANGED =1&lt;&lt;10;<br>    public staticfinal int SCREEN_BRIGHTNESS_CHANGED =1&lt;&lt;11;</p>
<p>当然还有很多，这里列出了一些常用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;WindowManager是Android中一个重要的服务（Service ）。WindowManager Service 是全局的，是唯一
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.xiangzhihong.com/tags/Android/"/>
    
      <category term="深入系统" scheme="http://www.xiangzhihong.com/tags/%E6%B7%B1%E5%85%A5%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统服务" scheme="http://www.xiangzhihong.com/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 8新功能介绍</title>
    <link href="http://www.xiangzhihong.com/2016/09/28/Xcode%208%E6%96%B0%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.xiangzhihong.com/2016/09/28/Xcode 8新功能介绍/</id>
    <published>2016-09-27T16:00:00.000Z</published>
    <updated>2017-07-10T01:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Xcode 8正式版在9月13日已经推送给开发者下载，下载之后就出现了很多编译错误，之前的插件也不能用了，但是发现Xcode8把好多不错的插件功能整合到自身了，感觉这点也挺不错。<br>结合自己遇到的一些问题和网上的一些教程，今天整理下xcode 8的一些新老特性分享出来。</p>
<h3 id="创建工程更加人性化"><a href="#创建工程更加人性化" class="headerlink" title="创建工程更加人性化"></a>创建工程更加人性化</h3><p><img src="http://img.blog.csdn.net/20161212153914802?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="内置表情包-Sticker-Packs-和iMessage应用"><a href="#内置表情包-Sticker-Packs-和iMessage应用" class="headerlink" title="内置表情包(Sticker Packs)和iMessage应用"></a>内置表情包(Sticker Packs)和iMessage应用</h4><p><img src="http://img.blog.csdn.net/20161212154107414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="类名提示"><a href="#类名提示" class="headerlink" title="类名提示"></a>类名提示</h5><p>从Xcode8beta1就支持类名提示了,所以Xcode8正式版也支持类名提示,开发更加快捷了。</p>
<h5 id="Swift3-0-and-Swift2-3-随意切换"><a href="#Swift3-0-and-Swift2-3-随意切换" class="headerlink" title="Swift3.0 and Swift2.3 随意切换"></a>Swift3.0 and Swift2.3 随意切换</h5><p>值得一提的是Xcode8.0并没有做语法捆绑,在以往的版本中都是捆绑最新的语法，不过我在操作swift3.0语法的时候各种坑，好多以前的语法都不支持了（这有点吐槽苹果，java即使过时也是可以用的）。<br>那么我们怎么进行Swift语法环境的切换呢？<br><img src="http://img.blog.csdn.net/20161212155253492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20161212155321699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>Swift只能向上兼容,不能向下兼容（也就是说如果你用的是swift2.0写的代码在3.0是会报错的），这也是我朋友不建议我直接学swift，更新太快了。<br><img src="http://img.blog.csdn.net/20161212160132394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="新增日志筛选"><a href="#新增日志筛选" class="headerlink" title="新增日志筛选"></a>新增日志筛选</h5><p>以前搞Android开发的时候，Android studio是有日志筛选的，系统和我们自己的日志是可以分离的，现在xcode 8页新增了这一功能，对于我们调试，找bug是很好的。<br><img src="http://img.blog.csdn.net/20161212160527250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20161212160613854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="代码调试支持Runtime"><a href="#代码调试支持Runtime" class="headerlink" title="代码调试支持Runtime"></a>代码调试支持Runtime</h4><p>Xcode8新增Runtime调试,界面可以展示运行时的问题，更加方便我们发现问题。<br><img src="http://img.blog.csdn.net/20161212160835315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="Xcode-8适配"><a href="#Xcode-8适配" class="headerlink" title="Xcode 8适配"></a>Xcode 8适配</h5><p>在Xcode8之前，创建一个XIB或SB文件，都是一个600*600的方块XIB文件。在Xcode8之后，创建的XIB文件默认是6s尺寸的大小。但是这样有个问题，如果Xcode8打开过这个XIB文件，并选择Choose Device之后。其他的Xcode8以下版本的编译器，将无法再打开这个文件，会报以下错误：<br>The document “ViewController.xib” requires Xcode 8.0 or later. This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8.0 or later.<br>有两种方法解决这个问题：</p>
<p>你同事也升级Xcode8，比较推荐这种方式，应该迎接改变。<br>右击XIB或SB文件 -&gt; Open as -&gt; Source Code，删除xml文件中下面一行字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;&gt;</div></pre></td></tr></table></figure>
<h4 id="权限适配"><a href="#权限适配" class="headerlink" title="权限适配"></a>权限适配</h4><p>在iOS10之后需要在Info.plist中，添加新的字段获取权限，否则在iOS10上运行会导致崩溃。下面是一些常用的字段，如果有缺少的麻烦各位评论区补充一下。</p>
<p><img src="http://img.blog.csdn.net/20161212161425912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h4><p>苹果的推送在之前iOS8和iOS9的时候就发生过大的更新，推送功能越来越强大。在iOS10之后苹果推出了UserNotifications框架，可以通过这个框架更好的控制推送通知，可以更新、修改锁屏页面的推送消息，可以添加图片等功能。<br>但是在用Xcode8打包后，并且不对代码进行修改的情况下，会发现打包后苹果发来了一封邮件。这封邮件大概意思是如果需要使用推送通知，需要对代码做修改，否则将不能使用推送通知。<br>了解更多，请<a href="http://www.cocoachina.com/ios/20161024/17830.html" target="_blank" rel="external">xcode 8详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Xcode 8正式版在9月13日已经推送给开发者下载，下载之后就出现了很多编译错误，之前的插件也不能用了，但是发现Xcode8把好多不错的插
    
    </summary>
    
      <category term="ios" scheme="http://www.xiangzhihong.com/categories/ios/"/>
    
    
      <category term="ios" scheme="http://www.xiangzhihong.com/tags/ios/"/>
    
      <category term="Xcode" scheme="http://www.xiangzhihong.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>React Native程序调试</title>
    <link href="http://www.xiangzhihong.com/2016/09/06/React%20Native%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/"/>
    <id>http://www.xiangzhihong.com/2016/09/06/React Native开发调试/</id>
    <published>2016-09-05T16:00:00.000Z</published>
    <updated>2017-07-10T01:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做React Native开发时，少不了的需要对React Native程序进行调试。调试程序是每一位开发者的基本功，高效的调试不仅能提高开发效率，也能降低Bug率。</p>
<h1 id="Developer-Menu"><a href="#Developer-Menu" class="headerlink" title="Developer Menu"></a>Developer Menu</h1><h3 id="Android模拟器："><a href="#Android模拟器：" class="headerlink" title="Android模拟器："></a>Android模拟器：</h3><p>可以通过Command⌘ + M 快捷键来快速打开Developer Menu。也可以通过模拟器上的菜单键来打开。</p>
<h3 id="iOS模拟器："><a href="#iOS模拟器：" class="headerlink" title="iOS模拟器："></a>iOS模拟器：</h3><p>可以通过Command⌘ + D快捷键来快速打开Developer Menu。</p>
<h3 id="在真机上开启Developer-Menu："><a href="#在真机上开启Developer-Menu：" class="headerlink" title="在真机上开启Developer Menu："></a>在真机上开启Developer Menu：</h3><p>在真机上你可以通过摇动手机来开启Developer Menu。<br><img src="http://img.blog.csdn.net/20170422231229802?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="重载-JavaScript"><a href="#重载-JavaScript" class="headerlink" title="重载 JavaScript"></a>重载 JavaScript</h1><p>在只是修改了js代码的情况下，如果要预览修改结果，你不需要重新编译你的应用。在这种情况下，你只需要告诉React Native重新加载js即可。</p>
<h2 id="Reload-js"><a href="#Reload-js" class="headerlink" title="Reload js"></a>Reload js</h2><p>Reload js即将你项目中js代码部分重新生成bundle，然后传输给模拟器或手机。<br>在Developer Menu中有Reload选项，单击Reload让React Native重新加载js。对于iOS模拟器你也可以通过Command⌘ + R 快捷键来加载js，对于Android模拟器可以通过双击r键来加载j。</p>
<p>注：如果Command⌘ + R 无法使你的iOS模拟器加载js，则可以通过选中Hardware menu中Keyboard选项下的 “Connect Hardware Keyboard” 。</p>
<h2 id="Automatic-reloading"><a href="#Automatic-reloading" class="headerlink" title="Automatic reloading"></a>Automatic reloading</h2><p>在 Developer Menu中你会看到”Enable Live Reload” 选项，该选项提供了React Native动态加载的功能。当你的js代码发生变化后，React Native会自动生成bundle然后传输到模拟器或手机上，是不是觉得很方便。<br><img src="http://img.blog.csdn.net/20170422231437468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Hot-Reloading"><a href="#Hot-Reloading" class="headerlink" title="Hot Reloading"></a>Hot Reloading</h2><p>另外，Developer Menu中还有一项需要特别介绍的，就是”Hot Reloading”热加载，如果说Enable Live Reload解放了你的双手的话，那么Hot Reloading不但解放了你的双手而且还解放了你的时间。 当你每次保存代码时Hot Reloading功能便会生成此次修改代码的增量包，然后传输到手机或模拟器上以实现热加载。相比 Enable Live Reload需要每次都返回到启动页面，Enable Live Reload则会在保持你的程序状态的情况下，就可以将最新的代码部署到设备上。<br><img src="http://img.blog.csdn.net/20170422231628867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Errors-and-Warnings"><a href="#Errors-and-Warnings" class="headerlink" title="Errors and Warnings"></a>Errors and Warnings</h2><p>在development模式下，js部分的Errors 和 Warnings会直接打印在手机或模拟器屏幕上，以红屏和黄屏展示。</p>
<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>React Native程序运行时出现的Errors会被直接显示在屏幕上，以红色的背景显示，并会打印出错误信息。 你也可以通过 console.error()来手动触发Errors。</p>
<p><img src="http://img.blog.csdn.net/20170422231719784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="Warnings"><a href="#Warnings" class="headerlink" title="Warnings"></a>Warnings</h3><p>React Native程序运行时出现的Warnings也会被直接显示在屏幕上，以黄色的背景显示，并会打印出警告信息。 你也可以通过 console.warn()来手动触发Warnings。 你也可以通过console.disableYellowBox = true来手动禁用Warnings的显示，或者通过console.ignoredYellowBox = [‘Warning: …’];来忽略相应的Warning。</p>
<p><img src="http://img.blog.csdn.net/20170422231758868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="Chrome-调试工具"><a href="#Chrome-调试工具" class="headerlink" title="Chrome 调试工具"></a>Chrome 调试工具</h1><h2 id="Chrome-开发工具"><a href="#Chrome-开发工具" class="headerlink" title="Chrome 开发工具"></a>Chrome 开发工具</h2><p>谷歌 Chrome 开发工具，是基于谷歌浏览器内含的一套网页制作和调试工具。开发者工具允许网页开发者深入浏览器和网页应用程序的内部。该工具可以有效地追踪布局问题，设置 JavaScript 断点并可深入理解代码的最优化策略。 Chrome 开发工具一共提供了8大组工具：</p>
<ul>
<li>Element 面板： 用于查看和编辑当前页面中的 HTML 和 CSS 元素。</li>
<li>Network 面板：用于查看 HTTP 请求的详细信息，如请求头、响应头及返回内容等。</li>
<li>Source 面板：用于查看和调试当前页面所加载的脚本的源文件。</li>
<li>TimeLine 面板： 用于查看脚本的执行时间、页面元素渲染时间等信息。</li>
<li>Profiles 面板：用于查看 CPU 执行时间与内存占用等信息。</li>
<li>Resource 面板：用于查看当前页面所请求的资源文件，如 HTML，CSS 样式文件等。</li>
<li>Audits 面板：用于优化前端页面，加速网页加载速度等。</li>
<li>Console 面板：用于显示脚本中所输出的调试信息，或运行测试脚本等。</li>
</ul>
<p>对于调试React Native应用来说，Sources和Console是使用频率很高的两个工具。</p>
<h1 id="Chrome调试React-Native程序"><a href="#Chrome调试React-Native程序" class="headerlink" title="Chrome调试React Native程序"></a>Chrome调试React Native程序</h1><h3 id="第一步：启动远程调试"><a href="#第一步：启动远程调试" class="headerlink" title="第一步：启动远程调试"></a>第一步：启动远程调试</h3><p>在Developer Menu下单击”Debug JS Remotely” 启动JS远程调试功能。此时Chrome会被打开，同时会创建一个“<a href="http://localhost:8081/debugger-ui.”" target="_blank" rel="external">http://localhost:8081/debugger-ui.”</a> Tab页。</p>
<p><img src="http://img.blog.csdn.net/20170422232007431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="第二步：打开Chrome开发者工具"><a href="#第二步：打开Chrome开发者工具" class="headerlink" title="第二步：打开Chrome开发者工具"></a>第二步：打开Chrome开发者工具</h3><p>在该“<a href="http://localhost:8081/debugger-ui.”Tab页下打开开发者工具。打开Chrome菜单-&gt;选择更多工具-&gt;选择开发者工具。你也可以通过快捷键(Command⌘" target="_blank" rel="external">http://localhost:8081/debugger-ui.”Tab页下打开开发者工具。打开Chrome菜单-&gt;选择更多工具-&gt;选择开发者工具。你也可以通过快捷键(Command⌘</a> + Option⌥ + I on Mac, Ctrl + Shift + I on Windows)打开开发者工具。<br><img src="http://img.blog.csdn.net/20170422232054961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170422232112588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>打开”RCTWebSocketExecutor.m “文件，将“localhost”改为你的电脑的ip，然后在Developer Menu下单击”Debug JS Remotely” 启动JS远程调试功能。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>在Android5.0以上设备上，将手机通过usb连接到你的电脑，然后通过adb命令行工具运行如下命令来设置端口转发。 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reverse tcp:8081 tcp:8081</div></pre></td></tr></table></figure>
<p>或者通过在“Developer Menu”下的“Dev Settings”中设置你的电脑ip来进行调试，这也是大多数推荐使用的方式。</p>
<p>注：在使用真机调试时，你需要确保你的手机和电脑处在同一个网段内。</p>
<h2 id="Chrome调试小技巧"><a href="#Chrome调试小技巧" class="headerlink" title="Chrome调试小技巧"></a>Chrome调试小技巧</h2><h3 id="Sources面板"><a href="#Sources面板" class="headerlink" title="Sources面板"></a>Sources面板</h3><p>Sources 面板提供了调试 JavaScript 代码的功能。它提供了图形化的V8 调试器。<br><img src="http://img.blog.csdn.net/20170422232348324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>Sources 面板可以让你看到你所要检查的页面的所有脚本代码，并在面板选择栏下方提供了一组标准控件，提供了暂停，恢复，步进等功能。在窗口的最下方的按钮可以在遇到异常(exception)时强制暂停。源码显示在单独的标签页，通过点击 打开文件导航面板，导航栏中会显示所有已打开的脚本文件。</p>
<h3 id="执行控工具"><a href="#执行控工具" class="headerlink" title="执行控工具"></a>执行控工具</h3><p>从上图可以看到“执行控工具”按钮在侧板顶部，让你可以按步执行代码，当你进行调试的时候这几个按钮非常有用：</p>
<ul>
<li>继续(Continue): 继续执行代码直到遇到下一个断点。</li>
<li>单步执行(Step over):<br>步进代码以查看每一行代码对变量作出的操作，当代码调用另一个函数时不会进入这个函数，使你可以专注于当前的函数。</li>
<li>跳入(Step into): 与 Step over 类似，但是当代码调用函数时，调试器会进去这个函数并跳转到函数的第一行。</li>
<li>跳出(Step out): 当你进入一个函数后，你可以点击 Step out 执行函数余下的代码并跳出该函数。</li>
<li>断点切换(Toggle breakpoints): 控制断点的开启和关闭，同时保持断点完好。</li>
</ul>
<h3 id="查看js文件"><a href="#查看js文件" class="headerlink" title="查看js文件"></a>查看js文件</h3><p>如果你想在开发者工具上预览你的js文件，可以在打开Sources tab下的debuggerWorker.js选项卡，该选项卡下会显示当前调试项目的所有js文件。</p>
<p><img src="http://img.blog.csdn.net/20170422232542482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="断点Breakpoint"><a href="#断点Breakpoint" class="headerlink" title="断点Breakpoint"></a>断点Breakpoint</h3><p>断点(Breakpoint) 是在脚本中设置好的暂停处。在DevTools中使用断点可以调试JavaScript代码，DOM更新和 network calls。如果你需要移除断点，单击蓝色标签，断点即被移除。<br><img src="http://img.blog.csdn.net/20170422232720811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>右键点击蓝色标签会打开一个菜单，菜单包含以下选项：执行到此(Continue to Here)，黑盒脚本(Blackbox scripts)，移除断点(Remove Breakpoint)， 编辑断点(Edit Breakpoint)，和 禁用断点(Disable Breakpoint)。在这里你可以对断点进行更高级的定制化的操作。</p>
<p><img src="http://img.blog.csdn.net/20170422232818331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="管理断点"><a href="#管理断点" class="headerlink" title="管理断点"></a>管理断点</h3><p>通过Chrome开发者工具的右边面板来统一管理你的断点。你可以通过断点前的复选框来启用和禁用断点，也可以单击右键来进行更多的操作(如：移除断点，移除所有断点，启用禁用断点等)。<br><img src="http://img.blog.csdn.net/20170422232937750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="全局断点"><a href="#全局断点" class="headerlink" title="全局断点"></a>全局断点</h3><p>全局断点的作用是，当程序出现异常时，会在异常的地方暂停，这对快速定位异的常位置很方便。<br>做iOS开发的同学都知道在Xcode中可以设置全局断点，其实在Chrome 开发者工具中也同样有与之对应的功能，叫“Pause On Caught Exceptions”。如果勾选上此功能，则即使所发生运行时异常的代码在 try/catch 范围内，Chrome 开发者工具也能够在错误代码处停住。<br><img src="http://img.blog.csdn.net/20170422233025616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><p><strong>执行到此(Continue to Here)</strong>：如果你想让程序立即跳到某一行时，这个功能会帮到你。如果在该行之前还有别的断点，程序会依次经过前面的断点。另外需要提出的是这个功能在任意一行代码的边栏(gutter line)前单击右键都会看到。</p>
<p><strong>黑盒脚本(Blackbox scripts)</strong>：黑盒脚本会从你的调用堆栈中隐藏第三方代码。</p>
<p><strong>编辑断点(Edit Breakpoint)</strong>：通过该功能你可以创建一个条件断点，你也可以在边栏(gutter line) 右键并选择添加条件断点(Add Conditional Breakpoint) 。在输入框中，输入一个可解析为真或假的表达式。仅当条件为真时，执行会在此暂停。<br><img src="http://img.blog.csdn.net/20170422233240830?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>附：<a href="http://www.jianshu.com/p/771c31943bb5" target="_blank" rel="external">React Developer Tools插件使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做React Native开发时，少不了的需要对React Native程序进行调试。调试程序是每一位开发者的基本功，高效的调试不仅能提高开发效率，也能降低Bug率。&lt;/p&gt;
&lt;h1 id=&quot;Developer-Menu&quot;&gt;&lt;a href=&quot;#Developer-Menu
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
      <category term="调试" scheme="http://www.xiangzhihong.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Promise机制详解</title>
    <link href="http://www.xiangzhihong.com/2016/09/05/Promise%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xiangzhihong.com/2016/09/05/Promise机制详解/</id>
    <published>2016-09-04T16:00:00.000Z</published>
    <updated>2017-07-10T01:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript 采用回调函数(callback)来处理异步编程。从同步编程到异步回调编程有一个适应的过程，但是如果出现多层回调嵌套，也就是我们常说的厄运的回调金字塔(Pyramid of Doom)，绝对是一种糟糕的编程体验。于是便有了 CommonJS 的 Promises/A 规范，用于解决回调金字塔问题。</p>
<h3 id="回调金字塔"><a href="#回调金字塔" class="headerlink" title="回调金字塔"></a>回调金字塔</h3><p>那么何为回调金字塔呢？简单的讲就是回调里面嵌套回调。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">asyncOperation(function(data)&#123;</div><div class="line">  // 处理 `data`</div><div class="line">  anotherAsync(function(data2)&#123;</div><div class="line">      // 处理 `data2`</div><div class="line">      yetAnotherAsync(function()&#123;</div><div class="line">          // 完成</div><div class="line">      &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>#Promise简介<br>那么什么是Promise机制呢？Promise代表一个目前还不可用，但是在未来的某个时间点可以被解析的值，它允许以一种同步的方式来编写异步代码。例如，使用Promise API执行异步调用远程服务，但是在发起请求前你并不知道返回的数据对象是什么样子，你可以创建一个Promise对象作为未来某个时间返回的数据对象，在此期间， Promise对象扮演了真实数据的代理角色。<br>例如，使用Promise进行网络请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">this.AsyncFunction(para).then(</div><div class="line">            (para)=&gt;&#123;</div><div class="line">             // 处理成功的事件</div><div class="line">            &#125;</div><div class="line">        ).catch(</div><div class="line">            (error)=&gt;&#123;</div><div class="line">             // 处理失败的事件</div><div class="line">            &#125; )</div></pre></td></tr></table></figure>
<p>Promises 将嵌套的 callback ，改造成一系列的.then的连缀调用，去除了层层缩进的糟糕代码风格。 Promises 不是一种解决具体问题的算法，而已一种更好的代码组织模式。接受新的组织模式同时，也逐渐以全新的视角来理解异步调用。</p>
<h2 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a>Then 方法</h2><p>一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。promise 的 then 方法接受两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<p>onFulfilled 和 onRejected 都是可选参数。如果 onFulfilled和onRejected 不是函数，其必须被忽略。onFulfilled和onRejected必须在执行后才能被调用，并且只能调用一次。</p>
<p>then 方法可以被同一个 promise 调用多次。当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调；当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调。</p>
<p>then 方法必须返回一个 promise 对象 。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise2 = promise1.then(onFulfilled, onRejected);</div></pre></td></tr></table></figure>
<p>如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：<a href="promise2, x">[Resolve]</a>。</p>
<h3 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a>Promise 解决过程</h3><p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 <a href="promise, x">[Resolve]</a>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p>
<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <a href="promise, x">[Resolve]</a> 需遵循以下步骤：</p>
<h4 id="x-与-promise-相等"><a href="#x-与-promise-相等" class="headerlink" title="x 与 promise 相等"></a>x 与 promise 相等</h4><p>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</p>
<h4 id="x-为-Promise"><a href="#x-为-Promise" class="headerlink" title="x 为 Promise"></a>x 为 Promise</h4><p>如果 x 为 Promise ，则使 promise 接受 x 的状态 ：</p>
<ul>
<li>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</li>
<li>如果 x 处于执行态，用相同的值执行 promise</li>
<li>如果 x 处于拒绝态，用相同的据因拒绝 promise x 为对象或函数</li>
</ul>
<h4 id="如果-x-为对象或者函数："><a href="#如果-x-为对象或者函数：" class="headerlink" title="如果 x 为对象或者函数："></a>如果 x 为对象或者函数：</h4><p>把 x.then 赋值给 then </p>
<ul>
<li>如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</li>
<li>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise<br>，第二个参数叫做 rejectPromise:</li>
<li>如果 resolvePromise 以值 y 为参数被调用，则运行 <a href="promise, y">[Resolve]</a></li>
<li>如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</li>
<li>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用<br>如果调用 then 方法抛出了异常 e：</li>
<li>如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise</li>
<li>如果 then 不是函数，以 x 为参数执行 promise</li>
<li>如果 x 不为对象或者函数，以 x 为参数执行 promise</li>
</ul>
<p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <a href="promise, thenable">[Resolve]</a> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise </p>
<h1 id="Promises规范"><a href="#Promises规范" class="headerlink" title="Promises规范"></a>Promises规范</h1><p>到目前为止Promises指定了A、B、D、A+…版本。</p>
<h2 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises /A"></a>Promises /A</h2><p>promise 表示一个最终值，该值由操作完成时返回。<br>promise 有三种状态：未完成 (unfulfilled)，完成 (fulfilled) 和失败 (failed)。<br>promise 的状态只能由未完成转换成完成，或者未完成转换成失败 。<br>promise 的状态转换只发生一次。<br>promise 有一个 then 方法， then 方法可以接受 3 个函数作为参数。前两个函数对应 promise 的两种状态 fulfilled 和 rejected 的回调函数。第三个函数用于处理进度信息（对进度回调的支持是可选的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">promiseSomething().then(function(fulfilled)&#123;</div><div class="line">        //当 promise 状态变成 fulfilled 时，调用此函数</div><div class="line">    &#125;,function(rejected)&#123;</div><div class="line">        //当 promise 状态变成 rejected 时，调用此函数</div><div class="line">    &#125;,function(progress)&#123;</div><div class="line">        //当返回进度信息时，调用此函数</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h2 id="Promises-B"><a href="#Promises-B" class="headerlink" title="Promises/B"></a>Promises/B</h2><p>在 Promises/A 的基础上， Promises/B 定义了一组 promise 模块需要实现的 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">when(value, callback, errback_opt)</div></pre></td></tr></table></figure>
<p>如果 value 不是一个 promise ，那么下一事件循环 callback 会被调用， value 作为 callback 的传入值。如果 value 是一个 promise ， promise 的状态已经完成或者变成完成时，那么下一事件循环 callback 会被调用， resolve 的值会被传入 callback ； promise 的状态已经失败或者变成失败时，那么下一事件循环 errback 会被调用， reason 会作为失败的理由传入 errback 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asap(value, callback, errback_opt)</div></pre></td></tr></table></figure>
<p>与 when 最大的区别，如果 value 不是一个 promise ，会被立即执行，不会等到下一事件循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enqueue(task Function)</div></pre></td></tr></table></figure>
<p>尽可能快地在接下来的事件循环调用 task 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get(object, name)</div></pre></td></tr></table></figure>
<p>返回一个获得对象属性的 promise 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">post(object, name, args)</div></pre></td></tr></table></figure>
<p>返回一个调用对象方法的 promise 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">put(object, name, value)</div></pre></td></tr></table></figure>
<p>返回一个修改对象属性的 promise 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">del(object, name)</div></pre></td></tr></table></figure>
<p>返回一个删除对象属性的 promise 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">makePromise(descriptor Object, fallback Function)</div></pre></td></tr></table></figure>
<p>返回一个 promise 对象，该对象必须是一个可调用的函数，也可能是可被实例化的构造函数。</p>
<p>综合示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       &quot;when&quot;: function(errback)&#123;...&#125;,</div><div class="line">       &quot;get&quot;: function(name)&#123;...&#125;,</div><div class="line">       &quot;put&quot;: function(name, value)&#123;...&#125;,</div><div class="line">       &quot;post&quot;: function(name, args)&#123;...&#125;,</div><div class="line">       &quot;del&quot;: function(name)&#123;...&#125;,</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defer()</div></pre></td></tr></table></figure>
<p>返回一个对象，该对象包含一个 resolve(value) 方法和一个 promise 属性。<br>当 resolve(value) 方法被第一次调用时， promise 属性的状态变成 完成，所有之前或之后观察该 promise 的 promise 的状态都被转变成 完成。 value 参数如果不是一个 promise ，会被包装成一个 promise 的 ref 。 resolve 方法会忽略之后的所有调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reject(reason String)</div></pre></td></tr></table></figure>
<p>返回一个被标记为 失败 的 promise 。<br>一个失败的 promise 上被调用 when(message) 方法时，会采用如下两种方法之一</p>
<ol>
<li>如果存在 errback ， errback 会以 reason 作为参数被调用。 when 方法会将 errback 的返回值返回。</li>
<li>如果不存在 errback ， when 方法返回一个新的 reject 状态的 promise 对象，以同一 reason 作为参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ref(value)</div></pre></td></tr></table></figure>
<p>如果 value 是 promise 对象，返回 value 本身。否则，返回一个 resolved 的 promise ，携带如下 handle 。</p>
<ol>
<li>when(errback),忽略 errback ，返回 resolved 值</li>
<li>get(name)，返回 resolved 值的对应属性。</li>
<li>put(name, value) ，设置 resolved 值的对应属性。</li>
<li>del(name)，删除 resolved 值的对应属性。</li>
<li>post(name, args), 调用 resolved 值的对应方法。</li>
<li>其他所有的调用都返回一个 reject ，并携带 “Promise does not handle NAME” 的理由。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isPromise(value) Boolean</div></pre></td></tr></table></figure>
<p>判断一个对象是否是 promise。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method(name String)</div></pre></td></tr></table></figure>
<p>获得一个返回 name 对应方法的 promise 。返回值是 “get”, “put”, “del” 和 “post” 对应的方法，但是会在下一事件循环返回。</p>
<h2 id="Promises-D"><a href="#Promises-D" class="headerlink" title="Promises/D"></a>Promises/D</h2><p>为了增加不同 promise 实现之间的可互操作性， Promises/D 规范对 promise 对象和 Promises/B 规范做了进一步的约定。以达到鸭子类型的效果（ Duck-type Promise ）。简单来说 Promises/D 规范，做了两件事情：</p>
<ol>
<li>如何判断一个对象是 Promise 类型。</li>
<li>对 Promises/B 规范进行细节补充。</li>
</ol>
<h3 id="判断Promise-对象"><a href="#判断Promise-对象" class="headerlink" title="判断Promise 对象"></a>判断Promise 对象</h3><p>Promise 对象必须是实现 promiseSend 方法。</p>
<ol>
<li>在 promise 库上下文中，如果对象包含 promiseSend 方法就可以甄别为 promise 对象</li>
<li><p>promiseSend 方法必须接受一个操作名称，作为第一个参数 操作名称是一个可扩展的集合，下面是一些保留名称:</p>
<p>when，此时第三个参数必须是 rejection 回调。<br>rejection 回调必须接受一个 rejection 原因(可以是任何值)作为第一个参数<br>get，此时第三个参数为属性名（字符串类型）<br>put，此时第三个参数为属性名（字符串类型）,第四个参数为新属性值。<br>del，此时第三个参数为属性名<br>post，此时第三个参数为方法的属性名，接下来的变参为方法的调用参数<br>isDef</p>
</li>
<li>promiseSend方法的第二个参数为 resolver 方法</li>
<li>promiseSend方法可能接受变参</li>
<li>promiseSend方法必须返回undefined</li>
</ol>
<h2 id="Promises-A-1"><a href="#Promises-A-1" class="headerlink" title="Promises/A+"></a>Promises/A+</h2><p>前面提到的 Promises/A/B/D 规范都是有 CommonJS 组织提出的， Promises/A+是有一个自称为Promises/A+ 组织发布的，该规范是以 Promises/A 作为基础进行补充和修订，旨在提高 promise 实现之间的可互操作性。</p>
<p>Promises/A+ 对.then方法进行细致的补充，定义了细致的Promise Resolution Procedure流程，并且将.then方法作为 promise 的对象甄别方法。此外， Promises/A+ 还提供了兼容性测试工具，以确定各个实现的兼容性。</p>
<h3 id="Promise判断"><a href="#Promise判断" class="headerlink" title="Promise判断"></a>Promise判断</h3><p><strong>状态机</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var PENDING = 0;</div><div class="line">var FULFILLED = 1;</div><div class="line">var REJECTED = 2;</div><div class="line"></div><div class="line">function Promise() &#123;</div><div class="line">  // store state which can be PENDING, FULFILLED or REJECTED</div><div class="line">  var state = PENDING;</div><div class="line"></div><div class="line">  // store value or error once FULFILLED or REJECTED</div><div class="line">  var value = null;</div><div class="line"></div><div class="line">  // store sucess &amp; failure handlers attached by calling .then or .done</div><div class="line">  var handlers = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>状态变迁</strong><br>仅支持两种状态变迁， fulfill 和 reject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Promise() &#123;</div><div class="line">    // ...</div><div class="line"></div><div class="line">  function fulfill(result) &#123;</div><div class="line">    state = FULFILLED;</div><div class="line">    value = result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function reject(error) &#123;</div><div class="line">    state = REJECTED;</div><div class="line">    value = error;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fulfill 和 reject 方法较为底层，通常更高级的 resolve 方法开放给外部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Promise() &#123;</div><div class="line"></div><div class="line">  // ...</div><div class="line"></div><div class="line">  function resolve(result) &#123;</div><div class="line">    try &#123;</div><div class="line">      var then = getThen(result);</div><div class="line">      if (then) &#123;</div><div class="line">        doResolve(then.bind(result), resolve, reject)</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      fulfill(result);</div><div class="line">    &#125; catch (e) &#123;</div><div class="line">      reject(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>resolve 方法可以接受一个普通值或者另一个 promise 作为参数，如果接受一个 promise 作为参数，等待其完成。 promise 不允许被另一个 promise fulfill ，所以需要开放 resolve 方法。 resolve 方法依赖一些帮助方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function getThen(value) &#123;</div><div class="line">  var t = typeof value;</div><div class="line">  if (value &amp;&amp; (t === &apos;object&apos; || t === &apos;function&apos;)) &#123;</div><div class="line">    var then = value.then;</div><div class="line">    if (typeof then === &apos;function&apos;) &#123;</div><div class="line">      return then;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">function doResolve(fn, onFulfilled, onRejected) &#123;</div><div class="line">  var done = false;</div><div class="line">  try &#123;</div><div class="line">    fn(function (value) &#123;</div><div class="line">      if (done) return</div><div class="line">      done = true</div><div class="line">      onFulfilled(value)</div><div class="line">    &#125;, function (reason) &#123;</div><div class="line">      if (done) return</div><div class="line">      done = true</div><div class="line">      onRejected(reason)</div><div class="line">    &#125;)</div><div class="line">  &#125; catch (ex) &#123;</div><div class="line">    if (done) return</div><div class="line">    done = true</div><div class="line">    onRejected(ex)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 resolve 和 doResolve 之间的递归很巧妙，用来处理 promise 的层层嵌套（ promise 的 value 是一个 promise ）。</p>
<p><strong>构造器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Promise(fn) &#123;</div><div class="line">    // ...</div><div class="line">    doResolve(fn, resolve, reject);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>.done 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function Promise(fn) &#123;</div><div class="line">  // ...</div><div class="line"></div><div class="line">  function handle(handler) &#123;</div><div class="line">    if (state === PENDING) &#123;</div><div class="line">      handlers.push(handler);</div><div class="line">    &#125; else &#123;</div><div class="line">      if (state === FULFILLED &amp;&amp;</div><div class="line">        typeof handler.onFulfilled === &apos;function&apos;) &#123;</div><div class="line">        handler.onFulfilled(value);</div><div class="line">      &#125;</div><div class="line">      if (state === REJECTED &amp;&amp;</div><div class="line">        typeof handler.onRejected === &apos;function&apos;) &#123;</div><div class="line">        handler.onRejected(value);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  this.done = function (onFulfilled, onRejected) &#123;</div><div class="line">    // ensure we are always asynchronous</div><div class="line">    setTimeout(function () &#123;</div><div class="line">      handle(&#123;</div><div class="line">        onFulfilled: onFulfilled,</div><div class="line">        onRejected: onRejected</div><div class="line">      &#125;);</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>.then 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function Promise(fn) &#123;</div><div class="line">    // ...</div><div class="line">    this.then = function (onFulfilled, onRejected) &#123;</div><div class="line">      var self = this;</div><div class="line">      return new Promise(function (resolve, reject) &#123;</div><div class="line">        return self.done(function (result) &#123;</div><div class="line">          if (typeof onFulfilled === &apos;function&apos;) &#123;</div><div class="line">            try &#123;</div><div class="line">              return resolve(onFulfilled(result));</div><div class="line">            &#125; catch (ex) &#123;</div><div class="line">              return reject(ex);</div><div class="line">            &#125;</div><div class="line">          &#125; else &#123;</div><div class="line">            return resolve(result);</div><div class="line">          &#125;</div><div class="line">        &#125;, function (error) &#123;</div><div class="line">          if (typeof onRejected === &apos;function&apos;) &#123;</div><div class="line">            try &#123;</div><div class="line">              return resolve(onRejected(error));</div><div class="line">            &#125; catch (ex) &#123;</div><div class="line">              return reject(ex);</div><div class="line">            &#125;</div><div class="line">          &#125; else &#123;</div><div class="line">            return reject(error);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>jQuery 1.8 之前的版本， jQuery 的 then 方法只是一种可以同时调用 done 、 fail 和 progress 这三种回调的速写方法，而 Promises/A 规范的 then 在行为上更像是 jQuery 的 pipe 。 jQuery 1.8 修正了这个问题，使 then 成为 pipe 的同义词。不过，由于向后兼容的问题， jQuery 的 Promise 再如何对 Promises/A 示好也不太会招人待见。</p>
<p>此外，在 Promises/A 规范中，由 then 方法生成的 Promise 对象是已执行还是已拒绝，取决于由 then 方法调用的那个回调是返回值还是抛出错误。在 JQuery 的 Promise 对象的回调中抛出错误是个糟糕的主意，因为错误不会被捕获。<br>最后一个例子揭示了，实现 Promise 的关键是实现好 doResolve 方法，在完事以后触发回调。而为了保证异步 setTimeout(fun, 0); 是关键一步。</p>
<p>附：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript 采用回调函数(callback)来处理异步编程。从同步编程到异步回调编程有一个适应的过程，但是如果出现多层回调嵌套，也就是我们常说的厄运的回调金字塔(Pyramid of Doom)，绝对是一种糟糕的编程体验。于是便有了 CommonJS 的 Prom
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Promise" scheme="http://www.xiangzhihong.com/tags/Promise/"/>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>高仿ios斗鱼界面</title>
    <link href="http://www.xiangzhihong.com/2016/09/05/ios%E9%AB%98%E4%BB%BF%E6%96%97%E9%B1%BCapp/"/>
    <id>http://www.xiangzhihong.com/2016/09/05/ios高仿斗鱼app/</id>
    <published>2016-09-04T16:00:00.000Z</published>
    <updated>2017-07-10T01:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>过去的2016年是一个直播年，各大平台都相继接入了直播频道，电商，社交…更是火了一批做视频的，譬如喵播，映客，都斗鱼等直播平台。全民直播，一下子掀起了直播的技术潮，今天要聊聊如何实现一个ios的直播app。<br>首先来看最终的效果：<br><img src="http://upload-images.jianshu.io/upload_images/428088-59c0c6faf4804622.gif?imageMogr2/auto-orient/strip" alt="这里写图片描述"><br>最近也是因为入门swift不久，在网上找了一个项目就开始模仿，本项目用到的第三方库：<br><a href="https://github.com/Alamofire/Alamofire/" target="_blank" rel="external">Alamofire</a><br><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="external">Kingfisher</a></p>
<h1 id="Swift3-0的蝶变"><a href="#Swift3-0的蝶变" class="headerlink" title="Swift3.0的蝶变"></a>Swift3.0的蝶变</h1><p>swift3.0相对于2.x，渐渐的脱离了oc和c的风格，不管是从命名规范还是新能上都有了较大的提升，笔者认为应该是未来一个相对稳定的版本，而不是1.0和2.0时代的实验版本。相对于2.x，我们来看3.0或以后的3.x主要有哪些特性：<br><strong>稳定二进制接口（ABI)</strong><br>API大家都知道是应用程序接口 API只是提供函数签名，而ABI是系统和语言层面的 如果ABI稳定 意味着以后Swift版本更新升级 我们不需要再修改老版本 Swift 语言编译的库了。<br><strong>弹性/韧性 解决易碎二进制接口问题</strong><br><a href="https://en.wikipedia.org/wiki/Fragile_binary_interface_problem" target="_blank" rel="external">Fragile binary interface problem</a>是面向对象编程语言的通病 如果在程序中引入了外部库 我们的的程序中使用并继承了该外部库中的类 如果外部库有改动 我们必须重新编译所有该类的继承树 而这类问题被称为<a href="https://en.wikipedia.org/wiki/Fragile_base_class" target="_blank" rel="external">脆弱的基类</a> (Fragile base class)<br><strong>可移植性</strong><br>这个对于高级语言是很重要的特性，这意味着Swift可被移植到其他平台上。<br><strong>全面支持泛型特性</strong><br>Swift 2.2已经很好的支持泛型 但是还不够完善，Swift 3.0开始 将全面支持泛型的所有特性。<br><strong>新的API设计规范</strong><br>Swift3.0 发布了新的语言设计规范 其中在Swift3.0中标准库和核心库将会遵循这个设计规范。<a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">规范地址</a><br><strong>从函数参数中删除var关键字</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func doSomethingWithVar(var i: Int) &#123;</div><div class="line">     i = 2 // This will NOT have an effect on the caller&apos;s Int that was passed, but i can be modified locally</div><div class="line">  &#125;</div><div class="line"></div><div class="line">func doSomethingWithInout(inout i: Int) &#123;</div><div class="line">       i = 2 // This will have an effect on the caller&apos;s Int that was passed.</div><div class="line">&#125;  </div><div class="line"></div><div class="line">doSomethingWithVar(x)  </div><div class="line"> print(x) // 1</div><div class="line"></div><div class="line">doSomethingWithInout(&amp;x)</div><div class="line"> print(x) // 2</div></pre></td></tr></table></figure>
<p>删除var是因为var与inout会产生歧义和混乱。<br><strong>为autoreleasepool添加错误处理</strong><br>旧版autoreleasepool处理错误方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func doWork() throws -&gt; Result &#123;</div><div class="line">   var result: Result? = nil</div><div class="line">   var error: ErrorProtocol? = nil</div><div class="line">   autoreleasepool &#123; </div><div class="line">          do &#123;</div><div class="line">            ... actual computation which hopefully assigns to result but might not ...</div><div class="line">         &#125; catch let e &#123;</div><div class="line">                       error = e</div><div class="line">          &#125;</div><div class="line">     &#125; </div><div class="line"></div><div class="line">    guard let result = result else &#123; </div><div class="line">              throw error! </div><div class="line">      &#125; </div><div class="line">          return result!</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Swift3.0 autoreleasepool 处理错误方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public func autoreleasepool&lt;Result&gt;(@noescape body: () throws -&gt; Result) rethrows -&gt; Result</div><div class="line"></div><div class="line">  func doWork() throws -&gt; Result &#123;</div><div class="line"></div><div class="line">     return try autoreleasepool</div><div class="line">         &#123; </div><div class="line">                 ... actual computation which either returns or throws       ...         </div><div class="line">         &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>允许直接引用（Default, Private, Repeat）关键字成员</strong><br>在Swift3.0之前我们引用default和repeat成员时 需要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let cell = UITableViewCell(style: .`default`, reuseIdentifier: nil)</div><div class="line">particleSystem.imageSequenceAnimationMode = SCNParticleImageSequenceAnimationMode.`repeat`</div></pre></td></tr></table></figure></p>
<p>Swift3.0时 允许我们直接访问default repeat 关键字成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let cell = UITableViewCell(style: .default, reuseIdentifier: nil)</div><div class="line">particleSystem.imageSequenceAnimationMode = SCNParticleImageSequenceAnimationMode.repeat</div></pre></td></tr></table></figure>
<p> <strong>将声明式@noescape和@autoclosure 改为类型属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func f(@noescape fn : () -&gt; ()) &#123;&#125; // declaration  attribute </div><div class="line"></div><div class="line">//新的语法</div><div class="line">func f(fn : @noescape () -&gt; ()) &#123;&#125; // type attribute.</div><div class="line">func f2(a : @autoclosure () -&gt; ()) &#123;&#125; // type attribute.</div></pre></td></tr></table></figure>
<p><strong>重命名 Debug 标示符</strong><br>Debug 标示符重命名后将会与#available #selector 关键字统一风格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__FILE__ -&gt;  #file</div><div class="line">__LINE__ -&gt; #line</div><div class="line">__COLUMN__ -&gt; #column</div><div class="line">__FUNCTION__ -&gt; #function</div><div class="line">__DSO_HANDLE__ -&gt; #dsohandle</div></pre></td></tr></table></figure>
<h1 id="斗鱼部分代码分析"><a href="#斗鱼部分代码分析" class="headerlink" title="斗鱼部分代码分析"></a>斗鱼部分代码分析</h1><p>本app采用的是mvvm的开发架构，做到业务，数据，页面的真正分离，我们来看几个核心的类：<br>base</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">import UIKit  </div><div class="line">  </div><div class="line">private let kItemMargin : CGFloat = 10  </div><div class="line">private let kHeaderViewH : CGFloat = 50  </div><div class="line">private let NormalCellID = &quot;NormalCellID&quot;  </div><div class="line">private let HeaderViewID = &quot;HeaderViewID&quot;  </div><div class="line">let kNormalItemW = (kScreenW - 33 * kItemMargin) / 2  </div><div class="line">let kNormalItemH = kNormalItemW * 3 / 4  </div><div class="line">let kPrettyItemH = kNormalItemW * 5 / 4  </div><div class="line">let PrettyCellID = &quot;PrettyCellID&quot;  </div><div class="line">  </div><div class="line">class BaseAnchorVC: BaseVC &#123;  </div><div class="line">  </div><div class="line">    //!表示用到的时候保证有值  </div><div class="line">    var baseVM : BaseVM!  </div><div class="line">      </div><div class="line">    lazy var collectionView : UICollectionView = &#123;[unowned self] in  </div><div class="line">        let layout = UICollectionViewFlowLayout()  </div><div class="line">        layout.itemSize = CGSize(width: kNormalItemW, height: kNormalItemH)  </div><div class="line">        layout.minimumLineSpacing = 0  </div><div class="line">        layout.minimumInteritemSpacing = kItemMargin  </div><div class="line">        layout.headerReferenceSize = CGSize(width: kScreenW, height: kHeaderViewH)  </div><div class="line">        layout.sectionInset = UIEdgeInsets(top: 0, left: kItemMargin, bottom: 0, right: kItemMargin)  </div><div class="line">          </div><div class="line">        let collectionView = UICollectionView(frame: self.view.bounds, collectionViewLayout: layout)  </div><div class="line">        collectionView.backgroundColor = UIColor.white  </div><div class="line">        collectionView.dataSource = self  </div><div class="line">        collectionView.delegate = self  </div><div class="line">        collectionView.autoresizingMask = [.flexibleHeight, .flexibleWidth]  </div><div class="line">          </div><div class="line">        collectionView.register(UINib(nibName: &quot;CollectionNormalCell&quot;, bundle: nil), forCellWithReuseIdentifier: NormalCellID)  </div><div class="line">        collectionView.register(UINib(nibName: &quot;CollectionPrettyCell&quot;, bundle: nil), forCellWithReuseIdentifier: PrettyCellID)  </div><div class="line">        collectionView.register(UINib(nibName: &quot;CollectionHeaderView&quot;, bundle: nil), forSupplementaryViewOfKind: UICollectionElementKindSectionHeader, withReuseIdentifier: HeaderViewID)  </div><div class="line">          </div><div class="line">        return collectionView  </div><div class="line">        &#125;()  </div><div class="line">      </div><div class="line">    override func viewDidLoad() &#123;  </div><div class="line">        super.viewDidLoad()  </div><div class="line">        setupUI()  </div><div class="line">        loadData()  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">extension BaseAnchorVC &#123;  </div><div class="line">    override func setupUI() &#123;  </div><div class="line">        contentView = collectionView  </div><div class="line">        view.addSubview(collectionView)  </div><div class="line">        super.setupUI()  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">extension BaseAnchorVC &#123;  </div><div class="line">    func loadData() &#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">extension BaseAnchorVC : UICollectionViewDataSource &#123;  </div><div class="line">    func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;  </div><div class="line">        return baseVM.anchorGroups.count  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;  </div><div class="line">        return baseVM.anchorGroups[section].anchors.count  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;  </div><div class="line">        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: NormalCellID, for: indexPath) as! CollectionNormalCell  </div><div class="line">        cell.anchor = baseVM.anchorGroups[indexPath.section].anchors[indexPath.item]  </div><div class="line">        return cell  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView &#123;  </div><div class="line">        let headerView = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: HeaderViewID, for: indexPath) as! CollectionHeaderView  </div><div class="line">        headerView.group = baseVM.anchorGroups[indexPath.section]  </div><div class="line">        return headerView  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">extension BaseAnchorVC : UICollectionViewDelegate &#123;  </div><div class="line">    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;  </div><div class="line">        let anchor = baseVM.anchorGroups[indexPath.section].anchors[indexPath.item]  </div><div class="line">        anchor.isVertical == 0 ? pushNormalRoomVc(anchor) : presentShowRoomVc(anchor)  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    private func presentShowRoomVc(_ anchor : AnchorModel) &#123;  </div><div class="line">        let showVc = ShowRoomVC()  </div><div class="line">        showVc.anchor = anchor  </div><div class="line">        present(showVc, animated: true, completion: nil)  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    private func pushNormalRoomVc(_ anchor : AnchorModel) &#123;  </div><div class="line">        let normalVc = NormalRoomVC()  </div><div class="line">        normalVc.anchor = anchor  </div><div class="line">        navigationController?.pushViewController(normalVc, animated: true)  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import UIKit  </div><div class="line">  </div><div class="line">class GameVC: BaseAnchorVC &#123;  </div><div class="line">    fileprivate lazy var gameVM : GameVM = GameVM()  </div><div class="line">    fileprivate lazy var menuView : MenuView = &#123;  </div><div class="line">        let menuView = MenuView.menuView()  </div><div class="line">        menuView.frame = CGRect(x: 0, y: -kMenuViewH, width: kScreenW, height: kMenuViewH)//设置collectionView的-y,放置menuView  </div><div class="line">        return menuView  </div><div class="line">    &#125;()  </div><div class="line">      </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">extension GameVC &#123;  </div><div class="line">    override func setupUI() &#123;  </div><div class="line">        super.setupUI()  </div><div class="line">        collectionView.addSubview(menuView)  </div><div class="line">        collectionView.contentInset = UIEdgeInsets(top: kMenuViewH, left: 0, bottom: 0, right: 0)//设置内边距  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">extension GameVC&#123;  </div><div class="line">    override func loadData() &#123;  </div><div class="line">        baseVM = self.gameVM  </div><div class="line">        gameVM.requestData &#123;  </div><div class="line">            self.collectionView.reloadData()  </div><div class="line">            var gameGroups = Array(self.gameVM.anchorGroups[1...15])//0...15 &amp; gameGroups.removeFirst()  </div><div class="line">            let moreGroup = AnchorGroup()  </div><div class="line">            moreGroup.tag_name = &quot;更多分类&quot;  </div><div class="line">            gameGroups.append(moreGroup)  </div><div class="line">            self.menuView.groups = gameGroups  </div><div class="line">            self.loadDataFinished()  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import UIKit  </div><div class="line">import Alamofire  </div><div class="line">  </div><div class="line">enum MethodType &#123;  </div><div class="line">    case get  </div><div class="line">    case post  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class HttpTools &#123;  </div><div class="line">    class func requestData(_ type : MethodType, URLString : String, parameters : [String : Any]? = nil, finishedCallback :  @escaping (_ result : Any) -&gt; ()) &#123;  </div><div class="line">        let method = type == .get ? HTTPMethod.get : HTTPMethod.post  </div><div class="line">        Alamofire.request(URLString, method: method, parameters: parameters).responseJSON &#123; (response) in  </div><div class="line">            guard let result = response.result.value else &#123;  </div><div class="line">                print(response.result.error)  </div><div class="line">                return  </div><div class="line">            &#125;  </div><div class="line">            finishedCallback(result)  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>附：<a href="https://github.com/xiangzhihong/douyu" target="_blank" rel="external">swift斗鱼app界面</a><br>     <a href="https://pan.baidu.com/s/1nv8iubJ?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0" target="_blank" rel="external">斗鱼完整代码oc</a><br>     <a href="http://www.jianshu.com/p/4d2032ca9cc5" target="_blank" rel="external">oc代码原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;过去的2016年是一个直播年，各大平台都相继接入了直播频道，电商，社交…更是火了一批做视频的，譬如喵播，映客，都斗鱼等直播平台。全民直播，一
    
    </summary>
    
      <category term="ios" scheme="http://www.xiangzhihong.com/categories/ios/"/>
    
    
      <category term="高仿" scheme="http://www.xiangzhihong.com/tags/%E9%AB%98%E4%BB%BF/"/>
    
      <category term="ios" scheme="http://www.xiangzhihong.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用自签名证书实现HTTPS请求</title>
    <link href="http://www.xiangzhihong.com/2016/09/01/iOS%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0HTTPS%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.xiangzhihong.com/2016/09/01/iOS使用自签名证书实现HTTPS请求/</id>
    <published>2016-08-31T16:00:00.000Z</published>
    <updated>2017-07-10T01:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在16年的WWDC中，Apple已表示将从2017年1月1日起，所有新提交的App必须强制性应用HTTPS协议来进行网络请求。<br>默认情况下非HTTPS的网络访问是禁止的并且不能再通过简单粗暴的向Info.plist中添加NSAllowsArbitraryLoads设置绕过ATS(App Transport Security)的限制（否则须在应用审核时进行说明并很可能会被拒）。所以还未进行相应配置的公司需要尽快将升级为HTTPS的事项提上进程了。</p>
<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><p>HTTPS就是HTTP协议上再加一层加密处理的SSL协议,即HTTP安全版。相比HTTP，HTTPS可以保证内容在传输过程中不会被第三方查看、及时发现被第三方篡改的传输内容、防止身份冒充，从而更有效的保证网络数据的安全。至于深层次的原理和介绍请查询相关资料和文档。<br>HTTPS客户端与服务器交互过程：<br>1、 客户端第一次请求时，服务器会返回一个包含公钥的数字证书给客户端；<br>2、 客户端生成对称加密密钥并用其得到的公钥对其加密后返回给服务器；<br>3、 服务器使用自己私钥对收到的加密数据解密，得到对称加密密钥并保存；<br>4、 然后双方通过对称加密的数据进行传输。<br><img src="http://img.blog.csdn.net/20161223160614593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>在HTTPS客户端与服务器第一次交互时，服务端返回给客户端的数字证书是让客户端验证这个数字证书是不是服务端的，证书所有者是不是该服务器，确保数据由正确的服务端发来，没有被第三方篡改。数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方身份。证书由公钥、证书主题(Subject)、数字签名(digital signature)等内容组成。其中数字签名就是证书的防伪标签，目前使用最广泛的SHA-RSA加密。<br>证书一般分为两种：<br>一种是向权威认证机构购买的证书，服务端使用该种证书时，因为苹果系统内置了其受信任的签名根证书，所以客户端不需额外的配置。为了证书安全，在证书发布机构公布证书时，证书的指纹算法都会加密后再和证书放到一起公布以防止他人伪造数字证书。而证书机构使用自己的私钥对其指纹算法加密，可以用内置在操作系统里的机构签名根证书来解密，以此保证证书的安全。如x509、RSA。<br>另一种是自己制作的证书，即自签名证书。好处是不需要花钱购买，但使用这种证书是不会受信任的，所以需要我们在代码中将该证书配置为信任证书。这就是本文的主要目的。如12306官网的证书。</p>
<h1 id="创建自定义证书"><a href="#创建自定义证书" class="headerlink" title="创建自定义证书"></a>创建自定义证书</h1><p>我们在使用自签名证书来实现HTTPS请求时，因为不像机构颁发的证书一样其签名根证书在系统中已经内置了，所以我们需要在App中内置自己服务器的签名根证书来验证数字证书。<br>首先将服务端生成的.cer格式的根证书添加到项目中，注意在添加证书要一定要记得勾选要添加的targets。这里有个地方要注意：苹果的ATS要求服务端必须支持TLS 1.2或以上版本；必须使用支持前向保密的密码；证书必须使用SHA-256或者更好的签名hash算法来签名，如果证书无效，则会导致连接失败。由于我在生成的根证书时签名hash算法低于其要求，在配置完请求时一直报NSURLErrorServerCertificateUntrusted = -1202错误，希望大家可以注意到这一点。<br>本文使用AFNetworking 3.0来配置证书校验。其中AFSecurityPolicy类中封装了证书校验的过程。<br>AFSecurityPolicy分三种验证模式：<br>1、AFSSLPinningModeNone：只验证证书是否在新人列表中<br>2、AFSSLPinningModeCertificate：验证证书是否在信任列表中，然后再对比服务端证书和客户端证书是否一致<br>3、 AFSSLPinningModePublicKey：只验证服务端与客户端证书的公钥是否一致<br>这里我们选第二种模式，并且对AFSecurityPolicy的allowInvalidCertificates和 validatesDomainName进行设置。</p>
<h2 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h2><p>我这边使用的是xca来制作了根证书，制作流程请参考<a href="http://www.2cto.com/Article/201411/347512.html，由于xca无法导出.jsk的后缀，因此我们只要制作完根证书后以.p12的格式导出就行了，之后的证书制作由命令行来完成。自制一个批处理文件，添加如下命令：" target="_blank" rel="external">http://www.2cto.com/Article/201411/347512.html，由于xca无法导出.jsk的后缀，因此我们只要制作完根证书后以.p12的格式导出就行了，之后的证书制作由命令行来完成。自制一个批处理文件，添加如下命令：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">set ip=%1%</div><div class="line">md %ip%</div><div class="line">keytool -importkeystore -srckeystore ca.p12 -srcstoretype PKCS12 -srcstorepass 123456 -destkeystore ca.jks -deststoretype JKS -deststorepass 123456</div><div class="line">keytool -genkeypair -alias server-%ip% -keyalg RSA -keystore ca.jks -storepass 123456 -keypass 123456 -validity 3650 -dname &quot;CN=%ip%, OU=ly, O=hik, L=hz, ST=zj, C=cn&quot;</div><div class="line">keytool -certreq -alias server-%ip% -storepass 123456 -file %ip%\server-%ip%.certreq -keystore ca.jks</div><div class="line">keytool -gencert -alias ca -storepass 123456 -infile %ip%\server-%ip%.certreq -outfile %ip%\server-%ip%.cer -validity 3650 -keystore ca.jks  </div><div class="line">keytool -importcert -trustcacerts -storepass 123456 -alias server-%ip% -file %ip%\server-%ip%.cer -keystore ca.jks</div><div class="line">keytool -delete -keystore ca.jks -alias ca -storepass 123456</div></pre></td></tr></table></figure>
<p>将上面加粗的ca.p12改成你导出的.p12文件的名称，123456改为你创建证书的密码。<br>然后在文件夹空白处按住ctrl+shift点击右键，选择在此处打开命令窗口，在命令窗口中输入“start.bat ip/域名”来执行批处理文件，其中start.bat是添加了上述命令的批处理文件，ip/域名即你服务器的ip或者域名。执行成功后会生成一个.jks文件和一个以你的ip或域名命名的文件夹，文件夹中有一个.cer的证书，这边的.jks文件将在服务端使用.cer文件将在客户端使用，到这里证书的准备工作就完成了。</p>
<h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>打开tomcat/conf目录下的server.xml文件将HTTPS的配置打开，并进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Connector URIEncoding=&quot;UTF-8&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; port=&quot;8443&quot; maxThreads=&quot;200&quot; scheme=&quot;https&quot; secure=&quot;true&quot; SSLEnabled=&quot;true&quot; sslProtocol=&quot;TLSv1.2&quot; sslEnabledProtocols=&quot;TLSv1.2&quot; keystoreFile=&quot;$&#123;catalina.base&#125;/ca/ca.jks&quot; keystorePass=&quot;123456&quot; clientAuth=&quot;false&quot; SSLVerifyClient=&quot;off&quot; netZone=&quot;你的ip或域名&quot;/&gt;</div></pre></td></tr></table></figure>
<p>keystoreFile是你.jks文件放置的目录，keystorePass是你制作证书时设置的密码，netZone填写你的ip或域名。注意苹果要求协议要TLSv1.2以上。</p>
<h2 id="iOS端配置"><a href="#iOS端配置" class="headerlink" title="iOS端配置"></a>iOS端配置</h2><p>首先把前面生成的.cer文件添加到项目中，注意在添加的时候选择要添加的targets。</p>
<h3 id="使用NSURLSession进行请求"><a href="#使用NSURLSession进行请求" class="headerlink" title="使用NSURLSession进行请求"></a>使用NSURLSession进行请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *urlString = @&quot;https://xxxxxxx&quot;;</div><div class="line">NSURL *url = [NSURL URLWithString:urlString];</div><div class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:10.0f];</div><div class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">NSURLSessionDataTask *task = [session dataTaskWithRequest:request];</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<p>需要实现NSURLSessionDataDelegate中的URLSession:didReceiveChallenge:completionHandler:方法来进行证书的校验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</div><div class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</div><div class="line">    NSLog(@&quot;证书认证&quot;);</div><div class="line">    if ([[[challenge protectionSpace] authenticationMethod] isEqualToString: NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">        do</div><div class="line">        &#123;</div><div class="line">            SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];</div><div class="line">            NSCAssert(serverTrust != nil, @&quot;serverTrust is nil&quot;);</div><div class="line">            if(nil == serverTrust)</div><div class="line">                break; /* failed */</div><div class="line">            /**</div><div class="line">             *  导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称</div><div class="line">             */</div><div class="line">            NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;ca&quot; ofType:@&quot;cer&quot;];//自签名证书</div><div class="line">            NSData* caCert = [NSData dataWithContentsOfFile:cerPath];</div><div class="line"></div><div class="line">            NSCAssert(caCert != nil, @&quot;caCert is nil&quot;);</div><div class="line">            if(nil == caCert)</div><div class="line">                break; /* failed */</div><div class="line">            </div><div class="line">            SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert);</div><div class="line">            NSCAssert(caRef != nil, @&quot;caRef is nil&quot;);</div><div class="line">            if(nil == caRef)</div><div class="line">                break; /* failed */</div><div class="line">            </div><div class="line">            //可以添加多张证书</div><div class="line">            NSArray *caArray = @[(__bridge id)(caRef)];</div><div class="line">            </div><div class="line">            NSCAssert(caArray != nil, @&quot;caArray is nil&quot;);</div><div class="line">            if(nil == caArray)</div><div class="line">                break; /* failed */</div><div class="line">            </div><div class="line">            //将读取的证书设置为服务端帧数的根证书</div><div class="line">            OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);</div><div class="line">            NSCAssert(errSecSuccess == status, @&quot;SecTrustSetAnchorCertificates failed&quot;);</div><div class="line">            if(!(errSecSuccess == status))</div><div class="line">                break; /* failed */</div><div class="line">            </div><div class="line">            SecTrustResultType result = -1;</div><div class="line">            //通过本地导入的证书来验证服务器的证书是否可信</div><div class="line">            status = SecTrustEvaluate(serverTrust, &amp;result);</div><div class="line">            if(!(errSecSuccess == status))</div><div class="line">                break; /* failed */</div><div class="line">            NSLog(@&quot;stutas:%d&quot;,(int)status);</div><div class="line">            NSLog(@&quot;Result: %d&quot;, result);</div><div class="line">            </div><div class="line">            BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed);</div><div class="line">            if (allowConnect) &#123;</div><div class="line">                NSLog(@&quot;success&quot;);</div><div class="line">            &#125;else &#123;</div><div class="line">                NSLog(@&quot;error&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* kSecTrustResultUnspecified and kSecTrustResultProceed are success */</div><div class="line">            if(! allowConnect)</div><div class="line">            &#123;</div><div class="line">                break; /* failed */</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">#if 0</div><div class="line">            /* Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success */</div><div class="line">            /*   since the user will likely tap-through to see the dancing bunnies */</div><div class="line">            if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError)</div><div class="line">                break; /* failed to trust cert (good in this case) */</div><div class="line">#endif</div><div class="line">            </div><div class="line">            // The only good exit point</div><div class="line">            NSLog(@&quot;信任该证书&quot;);</div><div class="line">            </div><div class="line">            NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">            completionHandler(NSURLSessionAuthChallengeUseCredential,credential);</div><div class="line">            return [[challenge sender] useCredential: credential</div><div class="line">                          forAuthenticationChallenge: challenge];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        while(0);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Bad dog</div><div class="line">    NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">    completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge,credential);</div><div class="line">    return [[challenge sender] cancelAuthenticationChallenge: challenge];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时即可成功请求到服务端。</p>
<h3 id="使用AFNetworking进行请求"><a href="#使用AFNetworking进行请求" class="headerlink" title="使用AFNetworking进行请求"></a>使用AFNetworking进行请求</h3><p>AFNetworking首先需要配置AFSecurityPolicy类，AFSecurityPolicy类封装了证书校验的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> AFSecurityPolicy分三种验证模式：</div><div class="line"> AFSSLPinningModeNone:只是验证证书是否在信任列表中</div><div class="line"> AFSSLPinningModeCertificate：该模式会验证证书是否在信任列表中，然后再对比服务端证书和客户端证书是否一致</div><div class="line"> AFSSLPinningModePublicKey：只验证服务端证书与客户端证书的公钥是否一致</div><div class="line">*/</div><div class="line"></div><div class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</div><div class="line">    securityPolicy.allowInvalidCertificates = YES;//是否允许使用自签名证书</div><div class="line">    securityPolicy.validatesDomainName = NO;//是否需要验证域名，默认YES</div><div class="line"></div><div class="line">    AFHTTPSessionManager *_manager = [AFHTTPSessionManager manager];</div><div class="line">    _manager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">    _manager.securityPolicy = securityPolicy;</div><div class="line">    //设置超时</div><div class="line">    [_manager.requestSerializer willChangeValueForKey:@&quot;timeoutinterval&quot;];</div><div class="line">    _manager.requestSerializer.timeoutInterval = 20.f;</div><div class="line">    [_manager.requestSerializer didChangeValueForKey:@&quot;timeoutinterval&quot;];</div><div class="line">    _manager.requestSerializer.cachePolicy = NSURLRequestReloadIgnoringCacheData;</div><div class="line">    _manager.responseSerializer.acceptableContentTypes  = [NSSet setWithObjects:@&quot;application/xml&quot;,@&quot;text/xml&quot;,@&quot;text/plain&quot;,@&quot;application/json&quot;,nil];</div><div class="line"> </div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    [_manager setSessionDidReceiveAuthenticationChallengeBlock:^NSURLSessionAuthChallengeDisposition(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential *__autoreleasing *_credential) &#123;</div><div class="line">        </div><div class="line">        SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];</div><div class="line">        /**</div><div class="line">         *  导入多张CA证书</div><div class="line">         */</div><div class="line">        NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;ca&quot; ofType:@&quot;cer&quot;];//自签名证书</div><div class="line">        NSData* caCert = [NSData dataWithContentsOfFile:cerPath];</div><div class="line">        NSArray *cerArray = @[caCert];</div><div class="line">        weakSelf.manager.securityPolicy.pinnedCertificates = cerArray;</div><div class="line">        </div><div class="line">        SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert);</div><div class="line">        NSCAssert(caRef != nil, @&quot;caRef is nil&quot;);</div><div class="line">        </div><div class="line">        NSArray *caArray = @[(__bridge id)(caRef)];</div><div class="line">        NSCAssert(caArray != nil, @&quot;caArray is nil&quot;);</div><div class="line">        </div><div class="line">        OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray);</div><div class="line">        SecTrustSetAnchorCertificatesOnly(serverTrust,NO);</div><div class="line">        NSCAssert(errSecSuccess == status, @&quot;SecTrustSetAnchorCertificates failed&quot;);</div><div class="line">        </div><div class="line">        NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        __autoreleasing NSURLCredential *credential = nil;</div><div class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">            if ([weakSelf.manager.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">                if (credential) &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</div><div class="line">                &#125; else &#123;</div><div class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return disposition;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>由于服务端使用.jks是一个证书库，客户端获取到的证书可能不止一本，我这边获取到了两本，具体获取到基本可通过SecTrustGetCertificateCount方法获取证书个数，AFNetworking在evaluateServerTrust：forDomain：方法中，AFSSLPinningMode的类型为AFSSLPinningModeCertificate和AFSSLPinningModePublicKey的时候都有校验服务端的证书个数与客户端信任的证书数量是否一样，如果不一样的话无法请求成功，所以这边我就修改他的源码，当有一个校验成功时即算成功。<br>参考：<a href="http://www.jianshu.com/p/e6a26ecd84aa" target="_blank" rel="external">http://www.jianshu.com/p/e6a26ecd84aa</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在16年的WWDC中，Apple已表示将从2017年1月1日起，所有新提交的App必须强制性应用HTTPS协议来进行网络请求。&lt;br&gt;默认情
    
    </summary>
    
      <category term="ios" scheme="http://www.xiangzhihong.com/categories/ios/"/>
    
    
      <category term="ios" scheme="http://www.xiangzhihong.com/tags/ios/"/>
    
      <category term="https" scheme="http://www.xiangzhihong.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>React Native的Navigator详解</title>
    <link href="http://www.xiangzhihong.com/2016/08/29/React%20Native%E7%9A%84Navigator%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.xiangzhihong.com/2016/08/29/React Native的Navigator详解/</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2017-07-10T01:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前，通过官方文档，我们对<a href="http://blog.csdn.net/xiangzhihong8/article/details/52624367" target="_blank" rel="external">Navigator简介</a>。<br>在React Native开发中，官方推荐使用Navigator作为导航指示器，在早期的版本中ios/android中都使用Navigator作为通用导航栏，不过在在后来的版本中，由于Navigator对ios系统兼容较差，所以使用导航往往使用NavigatorIOS组件。</p>
<h1 id="Navigator和NavigatorIOS属性"><a href="#Navigator和NavigatorIOS属性" class="headerlink" title="Navigator和NavigatorIOS属性"></a>Navigator和NavigatorIOS属性</h1><h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p>Navigator设置方法: 初始化路由(initialRoute), 配置场景动画(configureScene), 渲染场景(renderScene)。如常见的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class SimpleView extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Navigator</div><div class="line">        style=&#123;&#123;flex:1&#125;&#125;</div><div class="line">        initialRoute=&#123;&#123;component: FirstPage&#125;&#125;</div><div class="line">        configureScene=&#123;this.configureScene&#125;</div><div class="line">        renderScene=&#123;this.renderScene&#125;/&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>getCurrentRoutes()    该进行返回存在的路由列表信息</li>
<li>jumpBack()    该进行回退操作  但是该不会卸载(删除)当前的页面</li>
<li>jumpForward()    进行跳转到相当于当前页面的下一个页面</li>
<li>jumpTo(route)    根据传入的一个路由信息，跳转到一个指定的页面(该页面不会卸载删除)</li>
<li>push(route)     导航切换到一个新的页面中，新的页面进行压入栈。通过jumpForward()方法可以回退过去</li>
<li>pop()   当前页面弹出来，跳转到栈中下一个页面，并且卸载删除掉当前的页面</li>
<li>replace(route)   只用传入的路由的指定页面进行替换掉当前的页面</li>
<li>replaceAtIndex(route,index)     传入路由以及位置索引，使用该路由指定的页面跳转到指定位置的页面</li>
<li>replacePrevious(route)    传入路由，通过指定路由的页面替换掉前一个页面</li>
<li>resetTo(route)  进行导航到新的界面，并且重置整个路由栈</li>
<li>immediatelyResetRouteStack(routeStack)   该通过一个路由页面数组来进行重置路由栈</li>
<li>popToRoute(route)   进行弹出相关页面，跳转到指定路由的页面，弹出来的页面会被卸载删除</li>
<li>popToTop()  进行弹出页面，导航到栈中的第一个页面，弹出来的所有页面会被卸载删除</li>
</ul>
<h2 id="Navigator-IOS"><a href="#Navigator-IOS" class="headerlink" title="Navigator.IOS"></a>Navigator.IOS</h2><p>NavigatorIOS包装了UIKit的导航功能，可以使用左划功能来返回到上一界面。</p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>push(route) ：导航器跳转到一个新的路由。</li>
<li>pop() ：回到上一页。</li>
<li>popN(n) ：回到N页之前。当N=1的时候，效果和 pop() 一样。</li>
<li>replace(route) ：替换当前页的路由，并立即加载新路由的视图。</li>
<li>replacePrevious(route) ：替换上一页的路由/视图。</li>
<li>replacePreviousAndPop(route) ：替换上一页的路由/视图并且立刻切换回上一页。</li>
<li>resetTo(route) ：替换最顶级的路由并且回到它。</li>
<li>popToRoute(route)： 一直回到某个指定的路由。</li>
<li>popToTop() ：回到最顶层的路由。<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3>barTintColor : 导航条的背景颜色<br>initalRoute : 在RN 中导航名为“路由”（学过网络的应该明白这个词的意思）, 作用就是指路的，大家可以这么理解，这个属性是一个方法，用来初始化导航的。<br>itemWrapperStyle : 为每一项定制样式，例如设置每一个页面的背景颜色<br>navigationBarHidden : 为true , 隐藏导航栏。<br>shadowHidden : 是否隐藏阴影，true／false。<br>tintColor : 导航栏上按钮的颜色设置。<br>titleTextColor : 导航栏上字体的颜色 。<br>translucent : 导航栏是否是半透明的，true／false。<br>push(route) : 加载一个新的界面（视图或者路由）并且路由到该界面。<br>pop() : 返回到上一个页面。<br>popN(n) : 一次性返回N个界面，当n ＝ 1 时，即相当于pop（）方法的效果。<br>replace（route）：替换当前的路由。<br>replacePrevious(route) : 替换前一个页面的视图并且回退过去。<br>resetTo(route) : 取代最顶层的路由并且回退过去。<br>popToTop() : 回到最上层视图。<br>完整代码实例:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class NavigatorDemo extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;NavigatorIOS</div><div class="line">        style=&#123;styles.container&#125;</div><div class="line">        initialRoute=&#123;&#123;</div><div class="line">          title:&apos;movies&apos;,//这是navigationController的title。</div><div class="line">          component:SearchScreen,//注释：这里是要写的是相当于iOS开发里navigationController的rootViewController页面。</div><div class="line">        &#125;&#125;</div><div class="line">      /&gt;</div><div class="line"></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>二级页面逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">class SearchScreen extends Component&#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;131231232</div><div class="line">        &lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line"></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    backgroundColor: &apos;white&apos;,</div><div class="line">    top:64,</div><div class="line">  &#125;,</div><div class="line">  welcome: &#123;</div><div class="line">    fontSize: 20,</div><div class="line">    textAlign: &apos;center&apos;,</div><div class="line">    margin: 10,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line">module.exports = SearchScreen;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前，通过官方文档，我们对&lt;a href=&quot;http://blog.csdn.net/xiangzhihong8/article/detai
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
  </entry>
  
</feed>
